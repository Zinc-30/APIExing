Parallelize pandas apply
New to pandas , I already want to parallelize a row-wise apply operation . So far I found Parallelize apply after pandas groupby However , that only seems to work for grouped data frames .
My use case is different : I have a list of holidays and for my current row / date want to find the no-of-days before and after this day to the next holiday .
This is the function I call via apply :
How can I speed it up ?
edit
I experimented a bit with pythons pools - but it was neither nice code , nor did I get my computed results .
" python pools " - threads or processes ?
I was using multiprocessing.Pool ( processes= #ofCPU )
So multiprocessing is not guaranteed to speed up your code , but , since the code wasn't working correctly , it's hard to know what at all it was running there . You might want to make your question about that ( FWIW , this approach looks like your best bet to me ) .
Would cythonizing not be a good first step before you resort to parallelizing apply ?
As far as I understand the problem it is embarrassingly parallel e.g. each row is independent , so parallel execution should be better suited .
I think going down the route of trying stuff in parallel is probably over complicating this . I haven't tried this approach on a large sample so your mileage may vary , but it should give you an idea ...
Let's just start with some dates ...
We'll use some holiday data from ` pandas.tseries.holiday ` - note that in effect we want a ` DatetimeIndex ` ...
This gives us :
Now we find the indices of the nearest nearest holiday for the original dates using ` searchsorted ` :
Then take the difference between the two :
You'll need to be careful about the indices so you don't wrap around , and for the previous date , do the calculation with the ` indices - 1 ` but it should act as ( I hope ) a relatively good base .
I updated the minimum example with your code ( please see at the bootom ) . Trying to use " my dateimeIndices " for the holidays I receive an index out of bounds .
Comments are not for extended discussion ; this conversation has been moved to chat .
For the parallel approach this is the answer based on Parallelize apply after pandas groupby :
but I prefer @USER ' s approach because it does not require O ( n * number_of_holidays )