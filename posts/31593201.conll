pandas	O
iloc	B-API
vs	O
ix	B-API
vs	O
loc	B-API
explanation	O
?	O

Can	O
someone	O
explain	O
how	O
these	O
three	O
methods	O
of	O
slicing	O
are	O
different	O
?	O

I've	O
seen	O
the	O
docs	O
,	O

and	O
I've	O
seen	O
these	O
answers	O
,	O
but	O
I	O
still	O
find	O
myself	O
unable	O
to	O
explain	O
how	O
the	O
three	O
are	O
different	O
.	O

To	O
me	O
,	O
they	O
seem	O
interchangeable	O
in	O
large	O
part	O
,	O
because	O
they	O
are	O
at	O
the	O
lower	O
levels	O
of	O
slicing	O
.	O

For	O
example	O
,	O
say	O
we	O
want	O
to	O
get	O
the	O
first	O
five	O
rows	O
of	O
a	O
`	O
DataFrame	B-API
`	O
.	O

How	O
is	O
it	O
that	O
all	O
three	O
of	O
these	O
work	O
?	O

Can	O
someone	O
present	O
three	O
cases	O
where	O
the	O
distinction	O
in	O
uses	O
are	O
clearer	O
?	O

very	O
important	O
to	O
mention	O
the	O
SettingWithCopyWarning	O
scenarios	O
:	O
stackoverflow.com/questions/20625582	O
and	O
stackoverflow.com/questions/23688307	O

Note	O
that	O
ix	B-API
is	O
now	O
planned	O
for	O
deprecation	O
:	O
github.com/pandas-dev/pandas/issues/14218	O

Note	O
:	O
in	O
pandas	O
version	O
0.20.0	O
and	O
above	O
,	O
`	O
ix	B-API
`	O
is	O
deprecated	O
and	O
the	O
use	O
of	O
`	O
loc	B-API
`	O
and	O
`	O
iloc	B-API
`	O
is	O
encouraged	O
instead	O
.	O

I	O
have	O
left	O
the	O
parts	O
of	O
this	O
answer	O
that	O
describe	O
`	O
ix	B-API
`	O
intact	O
as	O
a	O
reference	O
for	O
users	O
of	O
earlier	O
versions	O
of	O
pandas	O
.	O

Examples	O
have	O
been	O
added	O
below	O
showing	O
alternatives	O
to	O
`	O
ix	B-API
`	O
.	O

First	O
,	O
a	O
recap	O
:	O

`	O
loc	B-API
`	O
works	O
on	O
labels	O
in	O
the	O
index	O
.	O

`	O
iloc	B-API
`	O
works	O
on	O
the	O
positions	O
in	O
the	O
index	O
(	O
so	O
it	O
only	O
takes	O
integers	O
)	O
.	O

`	O
ix	B-API
`	O
usually	O
tries	O
to	O
behave	O
like	O
`	O
loc	B-API
`	O
but	O
falls	O
back	O
to	O
behaving	O
like	O
`	O
iloc	B-API
`	O
if	O
the	O
label	O
is	O
not	O
in	O
the	O
index	O
.	O

It's	O
important	O
to	O
note	O
some	O
subtleties	O
that	O
can	O
make	O
`	O
ix	B-API
`	O
slightly	O
tricky	O
to	O
use	O
:	O

if	O
the	O
index	O
is	O
of	O
integer	O
type	O
,	O
`	O
ix	B-API
`	O
will	O
only	O
use	O
label-based	O
indexing	O
and	O
not	O
fall	O
back	O
to	O
position-based	O
indexing	O
.	O

If	O
the	O
label	O
is	O
not	O
in	O
the	O
index	O
,	O
an	O
error	O
is	O
raised	O
.	O

if	O
the	O
index	O
does	O
not	O
contain	O
only	O
integers	O
,	O
then	O
given	O
an	O
integer	O
,	O
`	O
ix	B-API
`	O
will	O
immediately	O
use	O
position-based	O
indexing	O
rather	O
than	O
label-based	O
indexing	O
.	O

If	O
however	O
`	O
ix	B-API
`	O
is	O
given	O
another	O
type	O
(	O
e.g.	O
a	O
string	O
)	O
,	O
it	O
can	O
use	O
label-based	O
indexing	O
.	O

To	O
illustrate	O
the	O
differences	O
between	O
the	O
three	O
methods	O
,	O
consider	O
the	O
following	O
Series	O
:	O

Then	O
`	O
s.iloc	O
[:	O
3	O
]`	O
returns	O
the	O
first	O
3	O
rows	O
(	O
since	O
it	O
looks	O
at	O
the	O
position	O
)	O
and	O
`	O
s.loc	O
[:	O
3	O
]`	O
returns	O
the	O
first	O
8	O
rows	O
(	O
since	O
it	O
looks	O
at	O
the	O
labels	O
):	O

Notice	O
`	O
s.ix	O
[:	O
3	O
]`	O
returns	O
the	O
same	O
Series	O
as	O
`	O
s.loc	O
[:	O
3	O
]`	O
since	O
it	O
looks	O
for	O
the	O
label	O
first	O
rather	O
than	O
going	O
by	O
position	O
(	O
and	O
the	O
index	O
is	O
of	O
integer	O
type	O
)	O
.	O

What	O
if	O
we	O
try	O
with	O
an	O
integer	O
label	O
that	O
isn't	O
in	O
the	O
index	O
(	O
say	O
`	O
6	O
`)	O
?	O

Here	O
`	O
s.iloc	O
[:	O
6	O
]`	O
returns	O
the	O
first	O
6	O
rows	O
of	O
the	O
Series	O
as	O
expected	O
.	O

However	O
,	O
`	O
s.loc	O
[:	O
6	O
]`	O
raises	O
a	O
KeyError	O
since	O
`	O
6	O
`	O
is	O
not	O
in	O
the	O
index	O
.	O

As	O
per	O
the	O
subtleties	O
noted	O
above	O
,	O
`	O
s.ix	O
[:	O
6	O
]`	O
now	O
raises	O
a	O
KeyError	O
because	O
it	O
tries	O
to	O
work	O
like	O
`	O
loc	B-API
`	O
but	O
can't	O
find	O
a	O
`	O
6	O
`	O
in	O
the	O
index	O
.	O

Because	O
our	O
index	O
is	O
of	O
integer	O
type	O
it	O
doesn't	O
fall	O
back	O
to	O
behaving	O
like	O
`	O
iloc	B-API
`	O
.	O

If	O
,	O
however	O
,	O
our	O
index	O
was	O
of	O
mixed	O
type	O
,	O
given	O
an	O
integer	O
`	O
ix	B-API
`	O
would	O
behave	O
like	O
`	O
iloc	B-API
`	O
immediately	O
instead	O
of	O
raising	O
a	O
KeyError	O
:	O

Keep	O
in	O
mind	O
that	O
`	O
ix	B-API
`	O
can	O
still	O
accept	O
non-integers	O
and	O
behave	O
like	O
`	O
loc	B-API
`	O
:	O

As	O
general	O
advice	O
,	O
if	O
you're	O
only	O
indexing	O
using	O
labels	O
,	O
or	O
only	O
indexing	O
using	O
integer	O
positions	O
,	O
stick	O
with	O
`	O
loc	B-API
`	O
or	O
`	O
iloc	B-API
`	O
to	O
avoid	O
unexpected	O
results	O
-	O
try	O
not	O
use	O
`	O
ix	B-API
`	O
.	O

Combining	O
position-based	O
and	O
label-based	O
indexing	O

Sometimes	O
given	O
a	O
DataFrame	B-API
,	O
you	O
will	O
want	O
to	O
mix	O
label	O
and	O
positional	O
indexing	O
methods	O
for	O
the	O
rows	O
and	O
columns	O
.	O

For	O
example	O
,	O
consider	O
the	O
following	O
DataFrame	B-API
.	O

How	O
best	O
to	O
slice	O
the	O
rows	O
up	O
to	O
and	O
including	O
'	O
c	O
'	O
and	O
take	O
the	O
first	O
four	O
columns	O
?	O

In	O
earlier	O
versions	O
of	O
pandas	O
(	O
before	O
0.20.0	O
)	O
`	O
ix	B-API
`	O
lets	O
you	O
do	O
this	O
quite	O
neatly	O
-	O
we	O
can	O
slice	O
the	O
rows	O
by	O
label	O
and	O
the	O
columns	O
by	O
position	O
(	O
note	O
that	O
for	O
the	O
columns	O
,	O
`	O
ix	B-API
`	O
default	O
to	O
position-based	O
slicing	O
since	O
the	O
label	O
`	O
4	O
`	O
is	O
not	O
a	O
column	O
name	O
):	O

In	O
later	O
versions	O
of	O
pandas	O
,	O
we	O
can	O
achieve	O
this	O
result	O
using	O
`	O
iloc	B-API
`	O
and	O
the	O
help	O
of	O
another	O
method	O
:	O

`	O
get_loc()	B-API
`	O
is	O
an	O
index	O
method	O
meaning	O
"	O
get	O
the	O
position	O
of	O
the	O
label	O
in	O
this	O
index	O
"	O
.	O

Note	O
that	O
since	O
slicing	O
with	O
`	O
iloc	B-API
`	O
is	O
exclusive	O
of	O
its	O
endpoint	O
,	O
we	O
must	O
add	O
1	O
to	O
this	O
value	O
if	O
we	O
want	O
row	O
'	O
c	O
'	O
as	O
well	O
.	O

There	O
are	O
further	O
examples	O
in	O
pandas	O
'	O
documentation	O
here	O
.	O

This	O
is	O
the	O
kind	O
of	O
example	O
that	O
would	O
be	O
SO	O
helpful	O
in	O
the	O
docs	O
.	O

Great	O
explanation	O
!	O

One	O
related	O
question	O
I've	O
always	O
had	O
is	O
what	O
relation	O
,	O
if	O
any	O
,	O
loc	B-API
,	O
iloc	B-API
and	O
ix	B-API
have	O
with	O
SettingWithCopy	O
warnings	O
?	O

There	O
is	O
some	O
documentation	O
but	O
to	O
be	O
honest	O
I'm	O
still	O
a	O
little	O
confused	O
pandas.pydata.org/pandas-docs/stable	O

@USER	O
:	O
`	O
loc	B-API
`	O
,	O
`	O
iloc	B-API
`	O
and	O
`	O
ix	B-API
`	O
might	O
still	O
trigger	O
the	O
warning	O
if	O
they	O
are	O
chained	O
together	O
.	O

Using	O
the	O
example	O
DataFrame	B-API
in	O
the	O
linked	O
docs	O
`	O
dfmi.loc	O
[:	O
,	O
'	O
one	O
']	O
.loc	B-API
[:	O
,	O
'	O
second	O
']`	O
triggers	O
the	O
warning	O
just	O
like	O
`	O
dfmi	O
[	O
'	O
one	O
']	O
[	O
'	O
second	O
']`	O
because	O
a	O
copy	O
of	O
data	O
(	O
rather	O
than	O
a	O
view	O
)	O
might	O
be	O
returned	O
by	O
the	O
first	O
indexing	O
operation	O
.	O

I	O
think	O
the	O
last	O
example	O
is	O
not	O
fully	O
correct	O
,	O
because	O
in	O
`	O
df.ix	B-API
[	O
1:3	O
,	O
:	O
'	O
b	O
']`	O
both	O
are	O
label-based	O
.	O

BTW	O
,	O
always	O
welcome	O
to	O
improve	O
the	O
docs	O
to	O
make	O
things	O
more	O
clear	O
!	O

Thanks	O
@USER	O
-	O
I've	O
updated	O
/	O
corrected	O
the	O
example	O
.	O

I'd	O
definitely	O
be	O
happy	O
to	O
have	O
a	O
look	O
at	O
the	O
docs	O
sometime	O
to	O
see	O
if	O
there's	O
anything	O
I	O
can	O
contribute	O
...	O

`	O
iloc	B-API
`	O
works	O
based	O
on	O
integer	O
positioning	O
.	O

So	O
no	O
matter	O
what	O
your	O
row	O
labels	O
are	O
,	O
you	O
can	O
always	O
,	O
e.g.	O
,	O
get	O
the	O
first	O
row	O
by	O
doing	O

or	O
the	O
last	O
five	O
rows	O
by	O
doing	O

You	O
can	O
also	O
use	O
it	O
on	O
the	O
columns	O
.	O

This	O
retrieves	O
the	O
3rd	O
column	O
:	O

You	O
can	O
combine	O
them	O
to	O
get	O
intersections	O
of	O
rows	O
and	O
columns	O
:	O

On	O
the	O
other	O
hand	O
,	O
`	O
.loc	B-API
`	O
use	O
named	O
indices	O
.	O

Let's	O
set	O
up	O
a	O
data	O
frame	O
with	O
strings	O
as	O
row	O
and	O
column	O
labels	O
:	O

Then	O
we	O
can	O
get	O
the	O
first	O
row	O
by	O

and	O
the	O
second	O
two	O
rows	O
of	O
the	O
`'	O
date	O
'`	O
column	O
by	O

and	O
so	O
on	O
.	O

Now	O
,	O
it's	O
probably	O
worth	O
pointing	O
out	O
that	O
the	O
default	O
row	O
and	O
column	O
indices	O
for	O
a	O
`	O
DataFrame	B-API
`	O
are	O
integers	O
from	O
0	O
and	O
in	O
this	O
case	O
`	O
iloc	B-API
`	O
and	O
`	O
loc	B-API
`	O
would	O
work	O
in	O
the	O
same	O
way	O
.	O

This	O
is	O
why	O
your	O
three	O
examples	O
are	O
equivalent	O
.	O

If	O
you	O
had	O
a	O
non-numeric	O
index	O
such	O
as	O
strings	O
or	O
datetimes	O
,	O
`	O
df.loc	B-API
[:	O
5	O
]`	O
would	O
raise	O
an	O
error	O
.	O

Also	O
,	O
you	O
can	O
do	O
column	O
retrieval	O
just	O
by	O
using	O
the	O
data	O
frame's	O
`	O
__getitem__	O
`	O
:	O

Now	O
suppose	O
you	O
want	O
to	O
mix	O
position	O
and	O
named	O
indexing	O
,	O
that	O
is	O
,	O
indexing	O
using	O
names	O
on	O
rows	O
and	O
positions	O
on	O
columns	O
(	O
to	O
clarify	O
,	O
I	O
mean	O
select	O
from	O
our	O
data	O
frame	O
,	O
rather	O
than	O
creating	O
a	O
data	O
frame	O
with	O
strings	O
in	O
the	O
row	O
index	O
and	O
integers	O
in	O
the	O
column	O
index	O
)	O
.	O

This	O
is	O
where	O
`	O
.ix	B-API
`	O
comes	O
in	O
:	O

EDIT	O
:	O

I	O
think	O
it's	O
also	O
worth	O
mentioning	O
that	O
you	O
can	O
pass	O
boolean	O
vectors	O
to	O
the	O
`	O
loc	B-API
`	O
method	O
as	O
well	O
.	O

For	O
example	O
:	O

Will	O
return	O
the	O
1st	O
and	O
3rd	O
rows	O
of	O
`	O
df	O
`	O
.	O

This	O
is	O
equivalent	O
to	O
`	O
df	O
[	O
b	O
]`	O
for	O
selection	O
,	O
but	O
it	O
can	O
also	O
be	O
used	O
for	O
assigning	O
via	O
boolean	O
vectors	O
:	O

Is	O
df.iloc	B-API
[:	O
,	O
:]	O
equivalent	O
to	O
all	O
rows	O
and	O
columns	O
?	O

It	O
is	O
,	O
as	O
would	O
be	O
`	O
df.loc	B-API
[:	O
,	O
:]	O
`	O
.	O

It	O
can	O
be	O
used	O
to	O
re-assign	O
the	O
values	O
of	O
the	O
entire	O
`	O
DataFrame	B-API
`	O
or	O
create	O
a	O
view	O
of	O
it	O
.	O

