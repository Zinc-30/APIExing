Delete	O
column	O
from	O
pandas	O
DataFrame	B-API
using	O
python	O
del	O

When	O
deleting	O
a	O
column	O
in	O
a	O
DataFrame	B-API
I	O
use	O
:	O

and	O
this	O
works	O
great	O
.	O

Why	O
can't	O
I	O
use	O
:	O

As	O
you	O
can	O
access	O
the	O
column	O
/	O
Series	O
as	O
`	O
df.column_name	O
`	O
,	O
I	O
expect	O
this	O
to	O
work	O
.	O

It's	O
difficult	O
to	O
make	O
`	O
del	O
df.column_name	O
`	O
work	O
simply	O
as	O
the	O
result	O
of	O
syntactic	O
limitations	O
in	O
Python	O
.	O

`	O
del	O
df	O
[	O
name	O
]`	O
gets	O
translated	O
to	O
`	O
df.__delitem__	O
(	O
name	O
)`	O
under	O
the	O
covers	O
by	O
Python	O

I	O
realize	O
this	O
is	O
a	O
super	O
old	O
"	O
answer	O
"	O
,	O
but	O
my	O
curiosity	O
is	O
piqued	O
-	O
why	O
is	O
that	O
a	O
syntactic	O
limitation	O
of	O
Python	O
?	O

`	O
class	O
A	O
(	O
object	O
):	O
def	O
__init__	O
(	O
self	O
):	O
self.var	O
=	O
1	O
`	O
sets	O
up	O
a	O
class	O
,	O
then	O
`	O
a	O
=	O
A()	O
;	O
del	O
a.var	O
`	O
works	O
just	O
fine	O
...	O

@USER	O
the	O
difference	O
is	O
that	O
when	O
a	O
column	O
is	O
to	O
be	O
removed	O
,	O
the	O
DataFrame	B-API
needs	O
to	O
have	O
its	O
own	O
handling	O
for	O
"	O
how	O
to	O
do	O
it	O
"	O
.	O

In	O
the	O
case	O
of	O
`	O
del	O
df	O
[	O
name	O
]`	O
,	O
it	O
gets	O
translated	O
to	O
`	O
df.__delitem__	O
(	O
name	O
)`	O
which	O
is	O
a	O
method	O
that	O
DataFrame	B-API
can	O
implement	O
and	O
modify	O
to	O
its	O
needs	O
.	O

In	O
the	O
case	O
of	O
`	O
del	O
df.name	O
`	O
,	O
the	O
member	O
variable	O
gets	O
removed	O
without	O
a	O
chance	O
for	O
any	O
custom-code	O
running	O
.	O

Consider	O
your	O
own	O
example	O
-	O
can	O
you	O
get	O
`	O
del	O
a.var	O
`	O
to	O
result	O
in	O
a	O
print	O
of	O
"	O
deleting	O
variable	O
"	O
?	O

If	O
you	O
can	O
,	O
please	O
tell	O
me	O
how	O
.	O

I	O
can't	O
:)	O

@USER	O
You	O
can	O
use	O
either	O
docs.python.org/3/reference/datamodel.html#object.__delattr_	O
_	O
or	O
descriptors	O
for	O
that	O
:	O
docs.python.org/3/howto/descriptor.html	O

@USER	O
good	O
point	O
.	O

I	O
was	O
answering	O
in	O
python	O
2	O
,	O
indeed	O
python	O
3	O
gives	O
more	O
flexibility	O
in	O
such	O
matters	O
.	O

Thanks	O
for	O
clarifying	O
.	O

@USER	O
Eugene's	O
comment	O
applies	O
to	O
Python	O
2	O
also	O
;	O
descriptors	O
have	O
been	O
in	O
Python	O
2	O
since	O
2.2	O
and	O
it	O
is	O
trivial	O
to	O
satisfy	O
your	O
requirement	O
;)	O

The	O
best	O
way	O
to	O
do	O
this	O
in	O
pandas	O
is	O
to	O
use	O
drop	O
:	O

where	O
`	O
1	O
`	O
is	O
the	O
axis	O
number	O
(	O
`	O
0	O
`	O
for	O
rows	O
and	O
`	O
1	O
`	O
for	O
columns	O
.	O
)	O

To	O
delete	O
the	O
column	O
without	O
having	O
to	O
reassign	O
`	O
df	O
`	O
you	O
can	O
do	O
:	O

Finally	O
,	O
to	O
drop	O
by	O
column	O
number	O
instead	O
of	O
by	O
column	O
label	O
,	O
try	O
this	O
to	O
delete	O
,	O
e.g.	O
the	O
1st	O
,	O
2nd	O
and	O
4th	O
columns	O
:	O

Is	O
this	O
recommended	O
over	O
`	O
del	O
`	O
for	O
some	O
reason	O
?	O

Though	O
this	O
method	O
of	O
deletion	O
has	O
its	O
merits	O
,	O
this	O
answer	O
does	O
not	O
really	O
answer	O
the	O
question	O
being	O
asked	O
.	O

True	O
@USER	O
,	O
but	O
due	O
to	O
the	O
title	O
of	O
the	O
question	O
,	O
most	O
people	O
arriving	O
here	O
will	O
do	O
so	O
via	O
trying	O
to	O
work	O
out	O
how	O
to	O
delete	O
a	O
column	O
.	O

Yeah	O
,	O
that's	O
a	O
good	O
point	O
@USER	O
.	O

In	O
fact	O
,	O
my	O
search	O
for	O
how	O
to	O
delete	O
a	O
column	O
led	O
me	O
here	O
;)	O

@USER	O
another	O
advantage	O
of	O
`	O
drop	B-API
`	O
over	O
`	O
del	O
`	O
is	O
that	O
`	O
drop	B-API
`	O
allows	O
you	O
to	O
drop	O
multiple	O
columns	O
at	O
once	O
,	O
perform	O
the	O
operation	O
inplace	O
or	O
not	O
,	O
and	O
also	O
delete	O
records	O
along	O
any	O
axis	O
(	O
especially	O
useful	O
for	O
a	O
3-D	O
matrix	O
or	O
`	O
Panel	O
`)	O

will	O
delete	O
one	O
or	O
more	O
columns	O
inplace	O
.	O

`	O
inplace	O
`	O
seems	O
to	O
have	O
been	O
added	O
pandas	O
0.13.1	O
and	O
won't	O
work	O
on	O
older	O
versions	O

A	O
note	O
about	O
this	O
answer	O
:	O
if	O
a	O
'	O
list	O
'	O
is	O
used	O
,	O
the	O
square	O
brackets	O
should	O
be	O
dropped	O
:	O
`	O
df.drop	B-API
(	O
list	O
,	O
inplace=True	O
,	O
axis=1	O
)`	O

this	O
should	O
really	O
be	O
the	O
accepted	O
answer	O
,	O
because	O
it	O
makes	O
clear	O
the	O
superiority	O
of	O
this	O
method	O
over	O
`	O
del	O
`	O
--	O
can	O
drop	O
more	O
than	O
one	O
column	O
at	O
once	O
.	O

Drop	O
by	O
index	O

delete	O
first	O
,	O
second	O
and	O
fourth	O
columns	O
:	O

delete	O
first	O
column	O
:	O

There	O
is	O
an	O
optional	O
parameter	O
`	O
inplace	O
`	O
so	O
that	O
the	O
original	O

data	O
can	O
be	O
modified	O
without	O
creating	O
a	O
copy	O
.	O

Popped	O

Column	O
selection	O
,	O
addition	O
,	O
deletion	O

delete	O
column	O
`	O
column-name	O
`	O
:	O

Examples	O
:	O

`	O
print	O
df	O
`	O
:	O

`	O
df.drop	B-API
(	O
df.columns	O
[[	O
0	O
]]	O
,	O
axis=1	O
,	O
inplace=True	O
)`	O

`	O
print	O
df	O
`	O
:	O

`	O
three	O
=	O
df.pop	B-API
(	O
'	O
three	O
')`	O

`	O
print	O
df	O
`	O
:	O

How	O
can	O
I	O
pop	O
a	O
row	O
in	O
pandas	O
?	O

@USER	O
You	O
can	O
use	O
a	O
transposed	O
dataframe	B-API
for	O
that	O
.	O

ex	O
-	O
`	O
df.T.pop	O
(	O
'	O
A	O
')`	O

@USER	O
-	O
Thank	O
you	O
.	O

The	O
actual	O
question	O
posed	O
,	O
missed	O
by	O
most	O
answers	O
here	O
is	O
:	O

Why	O
can't	O
I	O
use	O
`	O
del	O
df.column_name	O
`	O
?	O

At	O
first	O
we	O
need	O
to	O
understand	O
the	O
problem	O
,	O
which	O
requires	O
us	O
to	O
dive	O
into	O
python	O
magic	O
methods	O
.	O

As	O
Wes	O
points	O
out	O
in	O
his	O
answer	O
`	O
del	O
df	O
[	O
'	O
column	O
']`	O
maps	O
to	O
the	O
python	O
magic	O
method	O
`	O
df.__delitem__	O
(	O
'	O
column	O
')`	O
which	O
is	O
implemented	O
in	O
pandas	O
to	O
drop	O
the	O
column	O

However	O
,	O
as	O
pointed	O
out	O
in	O
the	O
link	O
above	O
about	O
python	O
magic	O
methods	O
:	O

In	O
fact	O
,	O
del	O
should	O
almost	O
never	O
be	O
used	O
because	O
of	O
the	O
precarious	O
circumstances	O
under	O
which	O
it	O
is	O
called	O
;	O
use	O
it	O
with	O
caution	O
!	O

You	O
could	O
argue	O
that	O
`	O
del	O
df	O
[	O
'	O
column_name	O
']`	O
should	O
not	O
be	O
used	O
or	O
encouraged	O
,	O
and	O
thereby	O
`	O
del	O
df.column_name	O
`	O
should	O
not	O
even	O
be	O
considered	O
.	O

However	O
,	O
in	O
theory	O
,	O
`	O
del	O
df.column_name	O
`	O
could	O
be	O
implemeted	O
to	O
work	O
in	O
pandas	O
using	O
the	O
magic	O
method	O
`	O
__delattr__	O
`	O
.	O

This	O
does	O
however	O
introduce	O
certain	O
problems	O
,	O
problems	O
which	O
the	O
`	O
del	O
df	O
[	O
'	O
column_name	O
']`	O
implementation	O
already	O
has	O
,	O
but	O
in	O
lesser	O
degree	O
.	O

Example	O
Problem	O

What	O
if	O
I	O
define	O
a	O
column	O
in	O
a	O
dataframe	B-API
called	O
"	O
dtypes	B-API
"	O
or	O
"	O
columns	O
"	O
.	O

Then	O
assume	O
I	O
want	O
to	O
delete	O
these	O
columns	O
.	O

`	O
del	O
df.dtypes	B-API
`	O
would	O
make	O
the	O
`	O
__delattr__	O
`	O
method	O
confused	O
as	O
if	O
it	O
should	O
delete	O
the	O
"	O
dtypes	B-API
"	O
attribute	O
or	O
the	O
"	O
dtypes	B-API
"	O
column	O
.	O

Architectural	O
questions	O
behind	O
this	O
problem	O

Is	O
a	O
dataframe	B-API
a	O

collection	O
of	O
columns	O
?	O

Is	O
a	O
dataframe	B-API
a	O
collection	O
of	O
rows	O
?	O

Is	O
a	O
column	O
an	O
attribute	O
of	O
a	O
dataframe	B-API
?	O

Pandas	O
answers	O
:	O

Yes	O
,	O
in	O
all	O
ways	O

No	O
,	O
but	O
if	O
you	O
want	O
it	O
to	O
be	O
,	O
you	O
can	O
use	O
the	O
`	O
.ix	B-API
`	O
,	O
`	O
.loc	B-API
`	O
or	O
`	O
.iloc	B-API
`	O
methods	O
.	O

Maybe	O
,	O
do	O
you	O
want	O
to	O
read	O
data	O
?	O

Then	O
yes	O
,	O
unless	O
the	O
name	O
of	O
the	O
attribute	O
is	O
already	O
taken	O
by	O
another	O
attribute	O
belonging	O
to	O
the	O
dataframe	B-API
.	O

Do	O
you	O
want	O
to	O
modify	O
data	O
?	O

Then	O
no	O
.	O

TLDR	O
;	O

You	O
cannot	O
do	O
`	O
del	O
df.column_name	O
`	O
because	O
pandas	O
has	O
a	O
quite	O
wildly	O
grown	O
architecture	O
that	O
needs	O
to	O
be	O
reconsidered	O
in	O
order	O
for	O
this	O
kind	O
of	O
cognitive	O
dissonance	O
not	O
to	O
occur	O
to	O
its	O
users	O
.	O

Protip	O
:	O

Don't	O
use	O
df.column_name	O
,	O
It	O
may	O
be	O
pretty	O
,	O
but	O
it	O
causes	O
cognitive	O
dissonance	O

Zen	O
of	O
Python	O
quotes	O
that	O
fits	O
in	O
here	O
:	O

There	O
are	O
multiple	O
ways	O
of	O
deleting	O
a	O
column	O
.	O

There	O
should	O
be	O
one	O
--	O
and	O
preferably	O
only	O
one	O
--	O
obvious	O
way	O
to	O
do	O
it	O
.	O

Columns	O
are	O
sometimes	O
attributes	O
but	O
sometimes	O
not	O
.	O

Special	O
cases	O
aren't	O
special	O
enough	O
to	O
break	O
the	O
rules	O
.	O

Does	O
`	O
del	O
df.dtypes	B-API
`	O
delete	O
the	O
dtypes	B-API
attribute	O
or	O
the	O
dtypes	B-API
column	O
?	O

In	O
the	O
face	O
of	O
ambiguity	O
,	O
refuse	O
the	O
temptation	O
to	O
guess	O
.	O

best	O
explanation	O
with	O
examples	O

from	O
version	O
0.16.1	O
you	O
can	O
do	O

And	O
this	O
also	O
supports	O
dropping	O
multiple	O
columns	O
,	O
some	O
of	O
which	O
need	O
not	O
exist	O
(	O
i.e.	O
without	O
raising	O
error	O
`	O
errors=	O
'	O
ignore	O
'`)	O
`	O
df.drop	B-API
([	O
'	O
column_1	O
'	O
,	O
'	O
column_2	O
']	O
,	O
axis=1	O
,	O
inplace=True	O
,	O
errors=	O
'	O
ignore	O
')`	O
,	O
if	O
such	O
an	O
application	O
desired	O
!	O

A	O
nice	O
addition	O
is	O
the	O
ability	O
to	O
drop	O
columns	O
only	O
if	O
they	O
exist	O
,	O
this	O
way	O
you	O
can	O
cover	O
more	O
use	O
cases	O
,	O
and	O
it	O
will	O
only	O
drop	O
the	O
existing	O
columns	O
from	O
the	O
labels	O
passed	O
to	O
it	O
:	O

simply	O
add	O
errors=	O
'	O
ignore	O
'	O
,	O
e.g	O
:	O

this	O
is	O
new	O
from	O
pandas	O
0.16.1	O
,	O
docs	O
are	O
here	O

It's	O
good	O
practice	O
to	O
always	O
use	O
the	O
`	O
[	O
]`	O
notation	O
,	O
one	O
reason	O
is	O
that	O
attribute	O
notation	O
(	O
`	O
df.column_name	O
`)	O
does	O
not	O
work	O
for	O
numbered	O
indices	O
:	O

In	O
pandas	O
0.16.1	O
+	O
you	O
can	O
drop	O
columns	O
only	O
if	O
they	O
exist	O
per	O
the	O
solution	O
posted	O
by	O
@USER	O
.	O

Prior	O
to	O
that	O
version	O
,	O
you	O
can	O
achieve	O
the	O
same	O
result	O
via	O
a	O
conditional	O
list	O
comprehension	O
:	O

You	O
should	O
use	O
drop()	O
.	O

Suppose	O
your	O
dataframe	B-API
name	O
is	O
df	O
.	O

the	O
dot	O
syntax	O
works	O
in	O
JS	O
but	O
not	O
in	O
python	O
.	O

Python	O
:	O
del	O
df	O
[	O
'	O
column_name	O
']	O

JS	O
:	O
del	O
df	O
[	O
'	O
column_name	O
']	O
OR	O
del	O
df.column_name	O

This	O
is	O
relevant	O
to	O
the	O
OP	O
.	O

