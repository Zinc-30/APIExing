Slice 2d array into smaller 2d arrays
Is there a way to slice a 2d array in numpy into smaller 2d arrays ?
Example
So I basically want to cut down a 2x4 array into 2 2x2 arrays . Looking for a generic solution to be used on images .
You should be able to break your array into " blocks " using some combination of ` reshape ` and ` swapaxes ` :
turns ` c `
into
I've posted an inverse function , ` unblockshaped ` , here , and an N-dimensional generalization here . The generalization gives a little more insight into the reasoning behind this algorithm .
Note that there is also superbatfish's
` blockwise_view ` . It arranges the
blocks in a different format ( using more axes ) but it has the advantage of ( 1 )
always returning a view and ( 2 ) being capable of handing arrays of any
dimension .
Could you make it more generic , so that block sizes are variables ? ( with the condition that blocks perfectly fit in the original array )
Thanks for the edit . Could your please explain the reasoning behind the algorithm ?
There was another question a couple of months ago which clued me in to the idea of using ` reshape ` and ` swapaxes ` . The ` h // nrows ` makes sense since this keeps the first block's rows together . It also makes sense that you'll need ` nrows ` and ` ncols ` to be part of the shape . ` -1 ` tells reshape to fill in whatever number is necessary to make the reshape valid . Armed with the form of the solution , I just tried things until I found the formula that works . I'm sorry I don't have a more insightful explanation for you .
It seems to me that this is a task for ` numpy.split ` or some variant .
e.g .
If you have a NxN image you can create , e.g. , a list of 2 NxN / 2 subimages , and then divide them along the other axis .
` numpy.hsplit ` and ` numpy.vsplit ` are also available .
There are some other answers that seem well-suited for your specific case already , but your question piqued my interest in the possibility of a memory-efficient solution usable up to the maximum number of dimensions that numpy supports , and I ended up spending most of the afternoon coming up with possible method . ( The method itself is relatively simple , it's just that I still haven't used most of the really fancy features that numpy supports so most of the time was spent researching to see what numpy had available and how much it could do so that I didn't have to do it . )
If you want a solution that also handles the cases when the matrix is
not equally divided , you can use this :
For now it just works when the big 2d array can be perfectly sliced into equally sized subarrays .
The code bellow slices
into this
` p ` ang ` q ` determine the block size
Code
You question practically the same as this one . You can use the one-liner with ` np.ndindex() ` and ` reshape() ` :
To create the result you want :