pandas	O
:	O
How	O
do	O
I	O
split	O
text	O
in	O
a	O
column	O
into	O
multiple	O
rows	O
?	O

I'm	O
working	O
with	O
a	O
large	O
csv	O
file	O
and	O
the	O
next	O
to	O
last	O
column	O
has	O
a	O
string	O
of	O
text	O
that	O
I	O
want	O
to	O
split	O
by	O
a	O
specific	O
delimiter	O
.	O

I	O
was	O
wondering	O
if	O
there	O
is	O
a	O
simple	O
way	O
to	O
do	O
this	O
using	O
pandas	O
or	O
python	O
?	O

I	O
want	O
to	O
split	O
by	O
the	O
space	O
`	O
(	O
'	O
')`	O
and	O
then	O
the	O
colon	O
`	O
(	O
'	O
:	O
')`	O
in	O
the	O
`	O
Seatblocks	O
`	O
column	O
,	O
but	O
each	O
cell	O
would	O
result	O
in	O
a	O
different	O
number	O
of	O
columns	O
.	O

I	O
have	O
a	O
function	O
to	O
rearrange	O
the	O
columns	O
so	O
the	O
`	O
Seatblocks	O
`	O
column	O
is	O
at	O
the	O
end	O
of	O
the	O
sheet	O
,	O
but	O
I'm	O
not	O
sure	O
what	O
to	O
do	O
from	O
there	O
.	O

I	O
can	O
do	O
it	O
in	O
excel	O
with	O
the	O
built	O
in	O
`	O
text-to-columns	O
`	O
function	O
and	O
a	O
quick	O
macro	O
,	O
but	O
my	O
dataset	O
has	O
too	O
many	O
records	O
for	O
excel	O
to	O
handle	O
.	O

Ultimately	O
,	O
I	O
want	O
to	O
take	O
records	O
such	O
John	O
Lennon's	O
and	O
create	O
multiple	O
lines	O
,	O
with	O
the	O
info	O
from	O
each	O
set	O
of	O
seats	O
on	O
a	O
separate	O
line	O
.	O

This	O
splits	O
the	O
Seatblocks	O
by	O
space	O
and	O
gives	O
each	O
its	O
own	O
row	O
.	O

Or	O
,	O
to	O
give	O
each	O
colon-separated	O
string	O
in	O
its	O
own	O
column	O
:	O

This	O
is	O
a	O
little	O
ugly	O
,	O
but	O
maybe	O
someone	O
will	O
chime	O
in	O
with	O
a	O
prettier	O
solution	O
.	O

@USER	O
give	O
an	O
index	O
to	O
the	O
Series	O
when	O
you	O
apply	B-API
;	O
they	O
will	O
become	O
column	O
names	O

While	O
this	O
answers	O
the	O
question	O
,	O
it	O
is	O
worth	O
mentioning	O
that	O
(	O
probably	O
)	O
split()	O
creates	O
a	O
list	O
for	O
each	O
row	O
,	O
which	O
blows	O
up	O
the	O
size	O
of	O
the	O
`	O
DataFrame	B-API
`	O
very	O
quickly	O
.	O

In	O
my	O
case	O
,	O
running	O
the	O
code	O
on	O
a	O
~200M	O
table	O
resulted	O
in	O
~10G	O
memory	O
(	O
+swap	O
...	O
)	O
usage	O
.	O

Though	O
I	O
am	O
not	O
sure	O
it	O
is	O
because	O
of	O
`	O
split()	O
`	O
,	O
because	O
simply	O
`	O
reduce()	O
`'	O
ing	O
through	O
the	O
column	O
works	O
like	O
a	O
charm	O
.	O

The	O
problem	O
then	O
may	O
lie	O
in	O
`	O
stack()	B-API
`	O
...	O

I	O
am	O
getting	O
the	O
error	O
`	O
NameError	O
:	O
name	O
'	O
Series	O
'	O
is	O
not	O
defined	O
`	O
for	O
this	O
.	O
where	O
is	O
`	O
Series	B-API
`	O
supposed	O
to	O
come	O
from	O
?	O

EDIT	O
:	O
nevermind	O
,	O
it	O
should	O
be	O
`	O
pandas.Series	B-API
`	O
since	O
it	O
is	O
referring	O
to	O
the	O
item	O
from	O
`	O
pandas	O
`	O

Yep	O
,	O
@USER	O
.	O

I	O
`	O
from	O
pandas	O
import	O
Series	O
`	O
for	O
convenience	O
/	O
brevity	O
.	O

Differently	O
from	O
Dan	O
,	O
I	O
consider	O
his	O
answer	O
quite	O
elegant	O
...	O
but	O
unfortunately	O
it	O
is	O
also	O
very	O
very	O
inefficient	O
.	O

So	O
,	O
since	O
the	O
question	O
mentioned	O
"	O
a	O
large	O
csv	O
file	O
"	O
,	O
let	O
me	O
suggest	O
to	O
try	O
in	O
a	O
shell	O
Dan's	O
solution	O
:	O

...	O
compared	O
to	O
this	O
alternative	O
:	O

...	O
and	O
this	O
:	O

The	O
second	O
simply	O
refrains	O
from	O
allocating	O
100	O
000	O
Series	O
,	O
and	O
this	O
is	O
enough	O
to	O
make	O
it	O
around	O
10	O
times	O
faster	O
.	O

But	O
the	O
third	O
solution	O
,	O
which	O
somewhat	O
ironically	O
wastes	O
a	O
lot	O
of	O
calls	O
to	O
str.split()	B-API
(	O
it	O
is	O
called	O
once	O
per	O
column	O
per	O
row	O
,	O
so	O
three	O
times	O
more	O
than	O
for	O
the	O
others	O
two	O
solutions	O
)	O
,	O
is	O
around	O
40	O
times	O
faster	O
than	O
the	O
first	O
,	O
because	O
it	O
even	O
avoids	O
to	O
instance	O
the	O
100	O
000	O
lists	O
.	O

And	O
yes	O
,	O
it	O
is	O
certainly	O
a	O
little	O
ugly	O
...	O

EDIT	O
:	O
this	O
answer	O
suggests	O
how	O
to	O
use	O
"	O
to_list()	O
"	O
and	O
to	O
avoid	O
the	O
need	O
for	O
a	O
lambda	O
.	O

The	O
result	O
is	O
something	O
like	O

which	O
is	O
even	O
more	O
efficient	O
than	O
the	O
third	O
solution	O
,	O
and	O
certainly	O
much	O
more	O
elegant	O
.	O

EDIT	O
:	O
the	O
even	O
simpler	O

works	O
too	O
,	O
and	O
is	O
almost	O
as	O
efficient	O
.	O

I'm	O
having	O
a	O
little	O
trouble	O
with	O
the	O
amount	O
of	O
memory	O
that	O
this	O
method	O
consumes	O
and	O
I'm	O
wondering	O
if	O
you	O
could	O
give	O
me	O
a	O
little	O
advice	O
.	O

I	O
have	O
a	O
DataFrame	B-API
that	O
contains	O
about	O
8000	O
rows	O
,	O
each	O
with	O
a	O
string	O
containing	O
9216	O
space	O
delimited	O
8-b	O
it	O
integers	O
.	O

This	O
is	O
roughly	O
75MB	O
,	O
but	O
when	O
I	O
apply	B-API
the	O
last	O
solution	O
verbatim	O
,	O
Python	O
eats	O
2GB	O
of	O
my	O
memory	O
.	O

Can	O
you	O
point	O
me	O
in	O
the	O
direction	O
of	O
some	O
source	O
that	O
would	O
tell	O
me	O
why	O
this	O
is	O
,	O
and	O
what	O
I	O
can	O
do	O
to	O
get	O
around	O
it	O
?	O

Thanks	O
.	O

You	O
have	O
a	O
lot	O
of	O
lists	O
and	O
very	O
small	O
strings	O
,	O
which	O
is	O
more	O
or	O
less	O
the	O
worst	O
case	O
for	O
memory	O
usage	O
in	O
python	O
(	O
and	O
the	O
intermediate	O
step	O
"	O
.split()	B-API
.tolist()	B-API
"	O
produces	O
pure	O
python	O
objects	O
)	O
.	O

What	O
I	O
would	O
probably	O
do	O
in	O
your	O
place	O
would	O
be	O
to	O
dump	O
the	O
DataFrame	B-API
to	O
a	O
file	O
,	O
and	O
then	O
open	O
it	O
as	O
csv	O
with	O
read_csv	B-API
(	O
...,	O
sep=	O
'	O
')	O
.	O

But	O
to	O
stay	O
on	O
topic	O
:	O
the	O
first	O
solution	O
(	O
together	O
with	O
the	O
third	O
,	O
which	O
however	O
should	O
be	O
awfully	O
slow	O
)	O
may	O
be	O
the	O
one	O
offering	O
you	O
the	O
lowest	O
memory	O
usage	O
among	O
the	O
4	O
,	O
since	O
you	O
have	O
a	O
relatively	O
small	O
number	O
of	O
relatively	O
long	O
rows	O
.	O

Hey	O
Pietro	O
,	O
I	O
tried	O
your	O
suggestion	O
of	O
saving	O
to	O
a	O
file	O
and	O
re-loading	O
,	O
an	O
it	O
worked	O
quite	O
well	O
.	O

I	O
ran	O
into	O
some	O
trouble	O
when	O
I	O
tried	O
to	O
do	O
this	O
in	O
a	O
StringIO	O
object	O
,	O
and	O
a	O
nice	O
solution	O
to	O
my	O
problem	O
has	O
been	O
posted	O
here	O
.	O

Your	O
last	O
suggestion	O
of	O
`	O
tolist()	B-API
`	O
is	O
perfect	O
.	O

In	O
my	O
case	O
I	O
only	O
wanted	O
one	O
of	O
the	O
pieces	O
of	O
data	O
in	O
the	O
list	O
and	O
was	O
able	O
to	O
directly	O
add	O
a	O
single	O
column	O
to	O
my	O
existing	O
df	O
by	O
using	O
.ix	B-API
:	O
`	O
df	O
[	O
'	O
newCol	O
']	O
=	O
pd.DataFrame	B-API
(	O
df.col.str.split()	O
.tolist()	B-API
)	O
.ix	B-API
[:	O
,	O
2	O
]`	O

Ahh	O
,	O
I	O
was	O
having	O
trouble	O
getting	O
this	O
to	O
work	O
at	O
first	O
-	O
something	O
about	O
`	O
obect	O
of	O
type	O
'	O
float	O
'	O
has	O
no	O
len()	O
`	O
which	O
was	O
baffling	O
,	O
until	O
I	O
realized	O
some	O
of	O
my	O
rows	O
had	O
`	O
NaN	O
`	O
in	O
them	O
,	O
as	O
opposed	O
to	O
`	O
str	B-API
`	O
.	O

Another	O
similar	O
solution	O
with	O
chaining	O
is	O
use	O
`	O
reset_index	B-API
`	O
and	O
`	O
rename	B-API
`	O
:	O

If	O
in	O
column	O
are	O
NOT	O
`	O
NaN	O
`	O
values	O
,	O
the	O
fastest	O
solution	O
is	O
use	O
`	O
list	O
`	O
comprehension	O
with	O
`	O
DataFrame	B-API
`	O
constructor	O
:	O

But	O
if	O
column	O
contains	O
`	O
NaN	O
`	O
only	O
works	O
`	O
str.split	B-API
`	O
with	O
parameter	O
`	O
expand=True	O
`	O
which	O
return	O
`	O
DataFrame	B-API
`	O
(	O
documentation	O
)	O
,	O
and	O
it	O
explain	O
why	O
it	O
is	O
slowier	O
:	O

Maybe	O
it's	O
worth	O
mentioning	O
that	O
you	O
necessarily	O
need	O
the	O
`	O
expand=True	O
`	O
option	O
working	O
with	O
`	O
pandas.DataFrames	O
`	O
while	O
using	O
`	O
.str	B-API
.split()	B-API
`	O
for	O
example	O
.	O

@USER	O
-	O
thank	O
you	O
for	O
comment	O
,	O
I	O
add	O
it	O
to	O
answer	O
.	O

