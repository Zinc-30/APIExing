pandas	O
-	O
searching	O
for	O
a	O
character	O
in	O
a	O
DataFrame	B-API

I	O
have	O
a	O
pandas	O
DataFrame	B-API
(	O
`	O
df	O
`)	O
that	O
I	O
need	O
to	O
search	O
for	O
a	O
semicolon	O
.	O

I	O
first	O
tried	O
with	O

`	O
semicolon_check	O
=	O
df.to_string()	B-API
.__contains__	O
(	O
'	O
;	O
')`	O
,	O

but	O
it	O
is	O
very	O
slow	O
and	O
in	O
case	O
of	O
large	O
DataFrames	O
I	O
run	O
into	O
a	O
Memory	O
error	O
.	O

Then	O
I	O
tried	O
to	O
loop	O
over	O
columns	O
with	O
`	O
.str	B-API
`	O
,	O
but	O
not	O
all	O
columns	O
are	O
strings	O
so	O
whenever	O
I	O
reached	O
a	O
numeric	O
column	O
I	O
received	O
an	O
error	O

`	O
AttributeError	O
:	O
Can	O
only	O
use	O
.str	B-API
accessor	O
with	O
string	O
values	O
,	O
which	O
use	O
np.object_	O
dtype	B-API
in	O
pandas	O
`	O

so	O
I	O
ended	O
up	O
with	O
this	O
code	O

`	O
for	O
col	O
in	O
df.columns	O
:	O

if	O
df	O
[	O
col	O
]	O
.dtype	B-API
==	O
'	O
O	O
'	O
:	O

if	O
df	O
[	O
col	O
]	O
.str	B-API
.contains	B-API
(	O
r	O
'	O
;	O
')	O
.any()	B-API
:	O

print	O
'	O
found	O
in	O
'	O
+	O
col	O
`	O

is	O
there	O
an	O
easier	O
way	O
to	O
achieve	O
the	O
goal	O
?	O

The	O
above	O
,	O
although	O
working	O
as	O
expected	O
seems	O
like	O
a	O
bit	O
too	O
much	O
of	O
an	O
effort	O
for	O
such	O
an	O
elementary	O
task	O
like	O
value	O
search	O
.	O

This	O
may	O
not	O
be	O
the	O
most	O
efficient	O
way	O
but	O
it	O
loops	O
safely	O
:	O
`	O
df.applymap	B-API
(	O
lambda	O
x	O
:	O
"	O
;	O
"	O
in	O
str	O
(	O
x	O
))`	O
.	O

You	O
can	O
filter	O
just	O
strings	O
columns	O
using	O
`	O
select_dtypes	B-API
`	O
and	O
then	O
call	O
`	O
apply	B-API
`	O
and	O
pass	O
a	O
`	O
lambda	O
`	O
to	O
call	O
`	O
str.contains	B-API
`	O
with	O
`	O
any	B-API
`	O
:	O

We	O
can	O
use	O
the	O
columns	O
array	O
from	O
the	O
filtered	O
df	O
along	O
with	O
the	O
mask	B-API
to	O
filter	O
the	O
cols	O
:	O

