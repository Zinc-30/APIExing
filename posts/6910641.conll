How	O
to	O
get	O
indices	O
of	O
N	O
maximum	O
values	O
in	O
a	O
numpy	O
array	O
?	O

Numpy	O
proposes	O
a	O
way	O
to	O
get	O
the	O
index	O
of	O
the	O
maximum	O
value	O
of	O
an	O
array	O
via	O
`	O
np.argmax	O
`	O
.	O

I	O
would	O
like	O
a	O
similar	O
thing	O
,	O
but	O
returning	O
the	O
indexes	O
of	O
the	O
N	O
maximum	O
values	O
.	O

For	O
instance	O
,	O
if	O
I	O
have	O
an	O
array	O
`	O
[	O
1	O
,	O
3	O
,	O
2	O
,	O
4	O
,	O
5	O
]`	O
,	O
it	O
`	O
function	O
(	O
array	O
,	O
n=3	O
)`	O
would	O
return	O
`	O
[	O
4	O
,	O
3	O
,	O
1	O
]`	O
.	O

Thanks	O
:)	O

possible	O
duplicate	O
of	O
python+numpy	O
:	O
efficient	O
way	O
to	O
take	O
the	O
min	O
/	O
max	O
n	O
values	O
and	O
indices	O
from	O
a	O
matrix	O

Your	O
question	O
is	O
not	O
really	O
well	O
defined	O
.	O

For	O
example	O
,	O
what	O
would	O
the	O
indices	O
(	O
you	O
expect	O
)	O
to	O
be	O
for	O
`	O
array	O
([	O
5	O
,	O
1	O
,	O
5	O
,	O
5	O
,	O
2	O
,	O
3	O
,	O
2	O
,	O
4	O
,	O
1	O
,	O
5	O
])`	O
,	O
whit	O
`	O
n=	O
3	O
`	O
?	O

Which	O
one	O
of	O
all	O
the	O
alternatives	O
,	O
like	O
`	O
[	O
0	O
,	O
2	O
,	O
3	O
]`	O
,	O
`	O
[	O
0	O
,	O
2	O
,	O
9	O
]`	O
,	O
`	O
...	O

`	O
would	O
be	O
the	O
correct	O
one	O
?	O

Please	O
elaborate	O
more	O
on	O
your	O
specific	O
requirements	O
.	O

Thanks	O

@USER	O
,	O
I	O
don't	O
really	O
care	O
about	O
which	O
one	O
is	O
supposed	O
to	O
be	O
returned	O
in	O
this	O
specific	O
case	O
.	O

Even	O
if	O
it	O
seem	O
logical	O
to	O
return	O
the	O
first	O
one	O
encountered	O
,	O
that's	O
not	O
a	O
requirement	O
for	O
me	O
.	O

`	O
argsort	B-API
`	O
might	O
be	O
a	O
viable	O
alternative	O
if	O
you	O
do	O
not	O
care	O
about	O
the	O
order	O
of	O
the	O
returned	O
indeces	O
.	O

See	O
my	O
answer	O
below	O
.	O

The	O
simplest	O
I've	O
been	O
able	O
to	O
come	O
up	O
with	O
is	O
:	O

This	O
involves	O
a	O
complete	O
sort	O
of	O
the	O
array	O
.	O

I	O
wonder	O
if	O
`	O
numpy	O
`	O
provides	O
a	O
built-in	O
way	O
to	O
do	O
a	O
partial	O
sort	O
;	O
so	O
far	O
I	O
haven't	O
been	O
able	O
to	O
find	O
one	O
.	O

If	O
this	O
solution	O
turns	O
out	O
to	O
be	O
too	O
slow	O
(	O
especially	O
for	O
small	O
`	O
n	O
`)	O
,	O
it	O
may	O
be	O
worth	O
looking	O
at	O
coding	O
something	O
up	O
in	O
Cython	O
.	O

Could	O
line	O
3	O
be	O
written	O
equivalently	O
as	O
`	O
arr.argsort()	O
[	O
-1	O
:	O
-4	O
:	O
-1	O
]`	O
?	O

I've	O
tried	O
it	O
in	O
interpreter	O
and	O
it	O
comes	O
up	O
with	O
the	O
same	O
result	O
,	O
but	O
I'm	O
wondering	O
if	O
it's	O
not	O
broken	O
by	O
some	O
example	O
.	O

@USER	O
Yes	O
that	O
should	O
be	O
equivalent	O
for	O
any	O
list	O
or	O
array	O
.	O

Alternatively	O
,	O
this	O
could	O
be	O
done	O
without	O
the	O
reversal	O
by	O
using	O
`	O
np.argsort	O
(	O
-arr	O
)	O
[:	O
3	O
]`	O
,	O
which	O
I	O
find	O
more	O
readable	O
and	O
to	O
the	O
point	O
.	O

what	O
does	O
[:	O
:	O
-1	O
]	O
mean	O
?	O

@USER	O

@USER	O
it	O
means	O
reverse	O
an	O
array	O
(	O
literally	O
,	O
takes	O
a	O
copy	O
of	O
an	O
array	O
from	O
unconstrained	O
min	O
to	O
unconstrained	O
max	O
in	O
a	O
reversed	O
order	O
)	O

@USER	O
so	O
the	O
two	O
`	O
:	O
`	O
does	O
not	O
related	O
to	O
dimensions	O
right	O
?	O

the	O
whole	O
expression	O
is	O
used	O
for	O
create	O
a	O
reversed	O
array	O
?	O

Am	O
I	O
understanding	O
correctly	O
?	O

Newer	O
NumPy	O
versions	O
(	O
1.8	O
and	O
up	O
)	O
have	O
a	O
function	O
called	O
`	O
argpartition	O
`	O
for	O
this	O
.	O

To	O
get	O
the	O
indices	O
of	O
the	O
four	O
largest	O
elements	O
,	O
do	O

Unlike	O
`	O
argsort	B-API
`	O
,	O
this	O
function	O
runs	O
in	O
linear	O
time	O
in	O
the	O
worst	O
case	O
,	O
but	O
the	O
returned	O
indices	O
are	O
not	O
sorted	O
,	O
as	O
can	O
be	O
seen	O
from	O
the	O
result	O
of	O
evaluating	O
`	O
a	O
[	O
ind	O
]`	O
.	O

If	O
you	O
need	O
that	O
too	O
,	O
sort	O
them	O
afterwards	O
:	O

To	O
get	O
the	O
top-	O
k	O
elements	O
in	O
sorted	O
order	O
in	O
this	O
way	O
takes	O
O	O
(	O
n	O
+	O
k	O
log	O
k	O
)	O
time	O
.	O

Actually	O
it	O
has	O
to	O
be	O
O	O
(	O
n	O
lg	O
k	O
)	O
time	O
.	O

Cannot	O
imagine	O
how	O
O	O
(	O
n	O
+	O
k	O
lg	O
k	O
)	O
can	O
be	O

@USER	O
`	O
argpartition	O
`	O
runs	O
in	O
linear	O
time	O
,	O
O	O
(	O
n	O
)	O
,	O
using	O
the	O
introselect	O
algorithm	O
.	O

The	O
subsequent	O
sort	O
only	O
handles	O
k	O
elements	O
,	O
so	O
that	O
runs	O
in	O
O	O
(	O
k	O
log	O
k	O
)	O
.	O

If	O
anybody	O
is	O
wondering	O
how	O
exactly	O
`	O
np.argpartition	O
`	O
and	O
its	O
sister	O
algorithm	O
`	O
np.partition	O
`	O
work	O
there	O
is	O
a	O
more	O
detailed	O
explanation	O
in	O
the	O
linked	O
question	O
:	O
stackoverflow.com/questions/10337533	O

@USER	O
:	O
why	O
did	O
you	O
use	O
-4	O
?	O

did	O
you	O
do	O
that	O
to	O
start	O
backward	O
?	O

(	O
since	O
k	O
being	O
positive	O
or	O
negative	O
works	O
the	O
same	O
for	O
me	O
!	O

it	O
only	O
prints	O
the	O
smallest	O
numbers	O
first	O
!	O

@USER	O
use	O
`	O
a=	O
np.array	O
([	O
9	O
,	O
4	O
,	O
4	O
,	O
3	O
,	O
3	O
,	O
9	O
,	O
0	O
,	O
4	O
,	O
6	O
,	O
0	O
])`	O
because	O
normal	O
python	O
lists	O
do	O
not	O
support	O
indexing	O
by	O
lists	O
,	O
unlike	O
`	O
np.array	O
`	O

EDIT	O
:	O
Modified	O
to	O
include	O
Ashwini	O
Chaudhary's	O
improvement	O
.	O

For	O
regular	O
Python	O
lists	O
:	O

If	O
you	O
use	O
Python	O
2	O
,	O
use	O
`	O
xrange	O
`	O
instead	O
of	O
`	O
range	O
`	O
.	O

Source	O
:	O
http://docs.python.org/3/library/heapq.html	O

There's	O
no	O
need	O
of	O
a	O
loop	O
at	O
all	O
here	O
:	O
`	O
heapq.nlargest	O
(	O
3	O
,	O
xrange	O
(	O
len	O
(	O
a	O
))	O
,	O
a.take	O
)`	O
.	O

For	O
Python	O
lists	O
we	O
can	O
use	O
`	O
.__getitem__	O
`	O
instead	O
of	O
`	O
.take	B-API
`	O
.	O

Simpler	O
yet	O
:	O

where	O
n	O
is	O
the	O
number	O
of	O
maximum	O
values	O
.	O

Can	O
this	O
be	O
done	O
for	O
a	O
2d	O
array	O
?	O

If	O
not	O
,	O
do	O
you	O
perhaps	O
know	O
how	O
?	O

If	O
you	O
don't	O
care	O
about	O
the	O
order	O
of	O
the	O
K-th	O
largest	O
elements	O
you	O
can	O
you	O
use	O
`	O
argpartition	O
`	O
,	O
which	O
should	O
perform	O
better	O
than	O
a	O
full	O
sort	O
through	O
`	O
argsort	B-API
`	O
.	O

Credits	O
to	O
this	O
question	O
.	O

I	O
ran	O
a	O
few	O
tests	O
and	O
it	O
looks	O
loke	O
`	O
argpartition	O
`	O
outperforms	O
`	O
argsort	B-API
`	O
as	O
the	O
size	O
of	O
the	O
array	O
and	O
the	O
value	O
of	O
K	O
increase	O
.	O

If	O
you	O
happen	O
to	O
be	O
working	O
with	O
a	O
multidimensional	O
array	O
then	O
you'll	O
need	O
to	O
flatten	O
and	O
unravel	O
the	O
indices	O
:	O

For	O
example	O
:	O

This	O
will	O
be	O
faster	O
than	O
a	O
full	O
sort	O
depending	O
on	O
the	O
size	O
of	O
your	O
original	O
array	O
and	O
the	O
size	O
of	O
your	O
selection	O
:	O

It	O
,	O
of	O
course	O
,	O
involves	O
tampering	O
with	O
your	O
original	O
array	O
.	O

Which	O
you	O
could	O
fix	O
(	O
if	O
needed	O
)	O
by	O
making	O
a	O
copy	O
or	O
replacing	O
back	O
the	O
original	O
values	O
.	O
...	O
whichever	O
is	O
cheaper	O
for	O
your	O
use	O
case	O
.	O

FWIW	O
,	O
your	O
solution	O
won't	O
provide	O
unambiguous	O
solution	O
in	O
all	O
situations	O
.	O

OP	O
should	O
describe	O
how	O
to	O
handle	O
these	O
unambiguous	O
cases	O
.	O

Thanks	O

@USER	O
The	O
OP's	O
question	O
is	O
a	O
little	O
ambiguous	O
.	O

An	O
implementation	O
,	O
however	O
,	O
is	O
not	O
really	O
open	O
to	O
interpretation	O
.	O

:)	O
The	O
OP	O
should	O
simply	O
refer	O
to	O
the	O
definition	O
of	O
np.argmax	O
docs.scipy.org/doc/numpy/reference/generated/numpy.argmax.ht	O
ml	O
to	O
be	O
sure	O
this	O
specific	O
solution	O
meets	O
the	O
requirements	O
.	O

It's	O
possible	O
that	O
any	O
solution	O
meeting	O
the	O
OP's	O
stated	O
reqirement	O
is	O
acceptable	O
..	O

Well	O
,	O
one	O
might	O
consider	O
the	O
implementation	O
of	O
`	O
argmax	B-API
(	O
.	O
)`	O
to	O
be	O
unambiguous	O
as	O
well	O
.	O

(	O
IMHO	O
it	O
tries	O
to	O
follow	O
some	O
kind	O
of	O
short	O
circuiting	O
logic	O
,	O
but	O
unfortunately	O
fails	O
to	O
provide	O
universally	O
acceptable	O
behavior	O
)	O
.	O

Thanks	O

`	O
bottleneck	O
`	O
has	O
a	O
partial	O
sort	O
function	O
,	O
if	O
the	O
expense	O
of	O
sorting	O
the	O
entire	O
array	O
just	O
to	O
get	O
the	O
N	O
largest	O
values	O
is	O
too	O
great	O
.	O

I	O
know	O
nothing	O
about	O
this	O
module	O
;	O
I	O
just	O
googled	O
`	O
numpy	O
partial	O
sort	O
`	O
.	O

For	O
multidimensional	O
arrays	O
you	O
can	O
use	O
`	O
axis	O
`	O
keyword	O
in	O
order	O
to	O
apply	B-API
the	O
partitioning	O
along	O
the	O
expected	O
axis	O
.	O

And	O
for	O
grabbing	O
the	O
items	O
:	O

But	O
note	O
that	O
this	O
won't	O
return	O
a	O
sorted	O
result	O
.	O

In	O
that	O
case	O
you	O
can	O
use	O
`	O
np.argsort()	O
`	O
along	O
the	O
intended	O
axis	O
:	O

Here	O
is	O
an	O
example	O
:	O

Now	O
the	O
result	O
list	O
would	O
contain	O
N	O
tuples	O
(	O
index	O
,	O
value	O
)	O
where	O
value	O
is	O
maximized	O

