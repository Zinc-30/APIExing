How	O
can	O
the	O
euclidean	O
distance	O
be	O
calculated	O
with	O
numpy	O
?	O

I	O
have	O
two	O
points	O
in	O
3	O
D:	O

And	O
I	O
want	O
to	O
calculate	O
the	O
distance	O
:	O

What's	O
the	O
best	O
way	O
to	O
do	O
this	O
with	O
Numpy	O
,	O
or	O
with	O
Python	O
in	O
general	O
?	O

I	O
have	O
:	O

Use	O
`	O
numpy.linalg.norm	O
`	O
:	O

I	O
knew	O
there	O
was	O
a	O
reason	O
for	O
me	O
not	O
to	O
accept	O
my	O
own	O
answer	O
:-)	O
.	O

Just	O
for	O
the	O
record	O
,	O
I	O
managed	O
to	O
see	O
Mark	O
Lavin's	O
answer	O
before	O
he	O
deleted	O
it	O
.	O

I	O
liked	O
it	O
better	O
for	O
the	O
link	O
to	O
Python's	O
docs	O
and	O
the	O
explanation	O
.	O

Can	O
you	O
add	O
some	O
details	O
?	O

The	O
linalg.norm	O
docs	O
can	O
be	O
found	O
here	O
:	O
docs.scipy.org/doc/numpy/reference/generated	O
My	O
only	O
real	O
comment	O
was	O
sort	O
of	O
pointing	O
out	O
the	O
connection	O
between	O
a	O
norm	O
(	O
in	O
this	O
case	O
the	O
Frobenius	O
norm	O
/	O
2-norm	O
which	O
is	O
the	O
default	O
for	O
norm	O
function	O
)	O
and	O
a	O
metric	O
(	O
in	O
this	O
case	O
Euclidean	O
distance	O
)	O
.	O

If	O
OP	O
wanted	O
to	O
calculate	O
the	O
distance	O
between	O
an	O
array	O
of	O
coordinates	O
it	O
is	O
also	O
possible	O
to	O
use	O
scipy.spatial.distance.cdist	O
.	O

There's	O
a	O
function	O
for	O
that	O
in	O
SciPy	O
,	O
it's	O
called	O
Euclidean	O

example	O
:	O

If	O
you	O
look	O
for	O
efficiency	O
it	O
is	O
better	O
to	O
use	O
the	O
numpy	O
function	O
.	O

The	O
scipy	O
distance	O
is	O
twice	O
as	O
slow	O
as	O
numpy.linalg.norm	O
(	O
a-b	O
)	O
(	O
and	O
numpy.sqrt	O
(	O
numpy.sum	O
((	O
a-b	O
)	O
**2	O
)))	O
.	O

On	O
my	O
machine	O
I	O
get	O
19.7	O
s	O
with	O
scipy	O
(	O
v0.15.1	O
)	O
and	O
8.9	O
s	O
with	O
numpy	O
(	O
v1.9.2	O
)	O
.	O

Not	O
a	O
relevant	O
difference	O
in	O
many	O
cases	O
but	O
if	O
in	O
loop	O
may	O
become	O
more	O
significant	O
.	O

From	O
a	O
quick	O
look	O
at	O
the	O
scipy	O
code	O
it	O
seems	O
to	O
be	O
slower	O
because	O
it	O
validates	O
the	O
array	O
before	O
computing	O
the	O
distance	O
.	O

Another	O
instance	O
of	O
this	O
problem	O
solving	O
method	O
.	O

As	O
soon	O
as	O
I	O
submitted	O
the	O
question	O
I	O
got	O
it	O
:	O

can	O
you	O
use	O
numpy's	O
sqrt	O
and	O
/	O
or	O
sum	O
implementations	O
?	O

That	O
should	O
make	O
it	O
faster	O
(	O
?	O
)	O
.	O

I	O
found	O
this	O
on	O
the	O
other	O
side	O
of	O
the	O
interwebs	O
`	O
norm	O
=	O
lambda	O
x	O
:	O
N.sqrt	O
(	O
N.square	O
(	O
x	O
)	O
.sum()	B-API
)`	O
;	O
`	O
norm	O
(	O
x-y	O
)`	O

scratch	O
that	O
.	O

it	O
had	O
to	O
be	O
somewhere	O
.	O
here	O
it	O
is	O
:	O
`	O
numpy.linalg.norm	O
(	O
x-y	O
)`	O

I	O
find	O
a	O
'	O
dist	O
'	O
function	O
in	O
matplotlib.mlab	O
,	O
but	O
i	O
don't	O
think	O
it's	O
handy	O
enough	O
.	O

I'm	O
posting	O
it	O
here	O
just	O
for	O
reference	O
.	O

Can	O
be	O
done	O
like	O
this	O
,	O
don't	O
know	O
how	O
fast	O
it	O
is	O
but	O
its	O
no	O
numpy	O
.	O

Is	O
a	O
nice	O
one	O
line	O
answer	O
.	O

However	O
,	O
if	O
speed	O
is	O
a	O
concern	O
I	O
would	O
recommend	O
experimenting	O
on	O
your	O
machine	O
.	O

I	O
found	O
that	O
using	O
the	O
`	O
math	O
`	O
library's	O
`	O
sqrt	O
`	O
with	O
the	O
`	O
**	O
`	O
operator	O
for	O
the	O
square	O
is	O
much	O
faster	O
on	O
my	O
machine	O
than	O
the	O
one	O
line	O
,	O
numpy	O
solution	O
.	O

I	O
ran	O
my	O
tests	O
using	O
this	O
simple	O
program	O
:	O

On	O
my	O
machine	O
,	O
`	O
math_calc_dist	O
`	O
runs	O
much	O
faster	O
than	O
`	O
numpy_calc_dist	O
`	O
:	O
1.5	O
seconds	O
versus	O
23.5	O
seconds	O
.	O

To	O
get	O
a	O
measurable	O
difference	O
between	O
`	O
fastest_calc_dist	O
`	O
and	O
`	O
math_calc_dist	O
`	O
I	O
had	O
to	O
up	O
`	O
TOTAL_LOCATIONS	O
`	O
to	O
6000	O
.	O

Then	O
`	O
fastest_calc_dist	O
`	O
takes	O
~50	O
seconds	O
while	O
`	O
math_calc_dist	O
`	O
takes	O
~60	O
seconds	O
.	O

You	O
can	O
also	O
experiment	O
with	O
`	O
numpy.sqrt	O
`	O
and	O
`	O
numpy.square	O
`	O
though	O
both	O
were	O
slower	O
than	O
the	O
`	O
math	O
`	O
alternatives	O
on	O
my	O
machine	O
.	O

My	O
tests	O
were	O
run	O
with	O
Python	O
2.6.6	O
.	O

You're	O
badly	O
misunderstanding	O
how	O
to	O
use	O
numpy	O
...	O

Don't	O
use	O
loops	O
or	O
list	O
comprehensions	O
.	O

If	O
you're	O
iterating	O
through	O
,	O
and	O
applying	O
the	O
function	O
to	O
each	O
item	O
,	O
then	O
,	O
yeah	O
,	O
the	O
numpy	O
functions	O
will	O
be	O
slower	O
.	O

The	O
whole	O
point	O
is	O
to	O
vectorize	O
things	O
.	O

If	O
I	O
move	O
the	O
numpy.array	O
call	O
into	O
the	O
loop	O
where	O
I	O
am	O
creating	O
the	O
points	O
I	O
do	O
get	O
better	O
results	O
with	O
numpy_calc_dist	O
,	O
but	O
it	O
is	O
still	O
10x	O
slower	O
than	O
fastest_calc_dist	O
.	O

If	O
I	O
have	O
that	O
many	O
points	O
and	O
I	O
need	O
to	O
find	O
the	O
distance	O
between	O
each	O
pair	O
I'm	O
not	O
sure	O
what	O
else	O
I	O
can	O
do	O
to	O
advantage	O
numpy	O
.	O

I	O
realize	O
this	O
thread	O
is	O
old	O
,	O
but	O
I	O
just	O
want	O
to	O
reinforce	O
what	O
Joe	O
said	O
.	O

You	O
are	O
not	O
using	O
numpy	O
correctly	O
.	O

What	O
you	O
are	O
calculating	O
is	O
the	O
sum	O
of	O
the	O
distance	O
from	O
every	O
point	O
in	O
p1	O
to	O
every	O
point	O
in	O
p2	O
.	O

The	O
solution	O
with	O
numpy	O
/	O
scipy	O
is	O
over	O
70	O
times	O
quicker	O
on	O
my	O
machine	O
.	O

Make	O
p1	O
and	O
p2	O
into	O
an	O
array	O
(	O
even	O
using	O
a	O
loop	O
if	O
you	O
have	O
them	O
defined	O
as	O
dicts	O
)	O
.	O

Then	O
you	O
can	O
get	O
the	O
total	O
sum	O
in	O
one	O
step	O
,	O
`	O
scipy.spatial.distance.cdist	O
(	O
p1	O
,	O
p2	O
)	O
.sum()	B-API
`	O
.	O

That	O
is	O
it	O
.	O

Or	O
use	O
`	O
numpy.linalg.norm	O
(	O
p1-p2	O
)	O
.sum()	B-API
`	O
to	O
get	O
the	O
sum	O
between	O
each	O
point	O
in	O
p1	O
and	O
the	O
corresponding	O
point	O
in	O
p2	O
(	O
i.e.	O
not	O
every	O
point	O
in	O
p1	O
to	O
every	O
point	O
in	O
p2	O
)	O
.	O

And	O
if	O
you	O
do	O
want	O
every	O
point	O
in	O
p1	O
to	O
every	O
point	O
in	O
p2	O
and	O
don't	O
want	O
to	O
use	O
scipy	O
as	O
in	O
my	O
previous	O
comment	O
,	O
then	O
you	O
can	O
use	O
np.apply_along_axis	O
along	O
with	O
numpy.linalg.norm	O
to	O
still	O
do	O
it	O
much	O
,	O
much	O
quicker	O
then	O
your	O
"	O
fastest	O
"	O
solution	O
.	O

Previous	O
versions	O
of	O
NumPy	O
had	O
very	O
slow	O
norm	O
implementations	O
.	O

In	O
current	O
versions	O
,	O
there's	O
no	O
need	O
for	O
all	O
this	O
.	O

You	O
can	O
just	O
substract	O
the	O
vectors	O
and	O
then	O
innerproduct	O
.	O

Following	O
your	O
example	O

Simple	O
Code	O
an	O
easy	O
to	O
understand	O
.	O

this	O
will	O
give	O
me	O
the	O
square	O
of	O
the	O
distance	O
.	O

you're	O
missing	O
a	O
sqrt	O
here	O
.	O

I	O
like	O
np.dot	O
(	O
dot	O
product	O
):	O

Having	O
`	O
a	O
`	O
and	O
`	O
b	O
`	O
as	O
you	O
defined	O
them	O
,	O
you	O
can	O
use	O
also	O
:	O

Here's	O
some	O
concise	O
code	O
for	O
Euclidean	O
distance	O
in	O
Python	O
given	O
two	O
points	O
represented	O
as	O
lists	O
in	O
Python	O
.	O

Numpy	O
also	O
accepts	O
lists	O
as	O
inputs	O
(	O
no	O
need	O
to	O
explicitly	O
pass	O
a	O
numpy	O
array	O
)	O

if	O
you	O
want	O
to	O
find	O
the	O
distance	O
of	O
a	O
specific	O
point	O
from	O
the	O
First	O
of	O
the	O
contractions	O
you	O
can	O
use	O
,	O
plus	O
you	O
can	O
do	O
it	O
with	O
as	O
many	O
as	O
dimensions	O
as	O
you	O
want	O
.	O

your	O
proposal	O
is	O
limited	O
to	O
two	O
dimensional	O
arrays	O
.	O

The	O
whole	O
point	O
is	O
to	O
have	O
generic	O
code	O
that	O
will	O
work	O
on	O
any	O
dimension	O
.	O

Calculate	O
euclidean	O
distance	O
for	O
multidimensional	O
space	O

