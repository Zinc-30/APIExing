Use	O
numpy	O
array	O
in	O
shared	O
memory	O
for	O
multiprocessing	O

I	O
would	O
like	O
to	O
use	O
a	O
numpy	O
array	O
in	O
shared	O
memory	O
for	O
use	O
with	O
the	O
multiprocessing	O
module	O
.	O

The	O
difficulty	O
is	O
using	O
it	O
like	O
a	O
numpy	O
array	O
,	O
and	O
not	O
just	O
as	O
a	O
ctypes	O
array	O
.	O

This	O
produces	O
output	O
such	O
as	O
:	O

The	O
array	O
can	O
be	O
accessed	O
in	O
a	O
ctypes	O
manner	O
,	O
e.g.	O
a	O
[	O
i	O
]	O
makes	O
sense	O
.	O

However	O
,	O
it	O

is	O
not	O
a	O
numpy	O
array	O
,	O
and	O
I	O
cannot	O
perform	O
operations	O
such	O
as	O
-1*a	O
,	O
or	O
a.sum()	O
.	O

I	O
suppose	O
a	O
solution	O
would	O
be	O
to	O
convert	O
the	O
ctypes	O
array	O
into	O
a	O
numpy	O
array	O
.	O

However	O
(	O
besides	O
not	O
being	O
able	O
to	O
make	O
this	O
work	O
)	O
,	O
I	O
don't	O
believe	O
it	O
would	O
be	O
shared	O
anymore	O
.	O

It	O
seems	O
there	O
would	O
be	O
a	O
standard	O
solution	O
to	O
what	O
has	O
to	O
be	O
a	O
common	O
problem	O
.	O

It's	O
not	O
the	O
same	O
as	O
this	O
one	O
?	O

stackoverflow.com/questions/5033799	O

It's	O
not	O
quite	O
the	O
same	O
question	O
.	O

The	O
linked	O
question	O
is	O
asking	O
about	O
`	O
subprocess	O
`	O
rather	O
than	O
`	O
multiprocessing	O
`	O
.	O

To	O
add	O
to	O
@USER	O
'	O
s	O
(	O
not	O
available	O
anymore	O
)	O
and	O
@USER	O
Gomersall's	O
answers	O
.	O

You	O
could	O
use	O
`	O
shared_arr.get_lock()	O
`	O
to	O
synchronize	O
access	O
when	O
needed	O
:	O

Example	O

If	O
you	O
don't	O
need	O
synchronized	O
access	O
or	O
you	O
create	O
your	O
own	O
locks	O
then	O
`	O
mp.Array()	O
`	O
is	O
unnecessary	O
.	O

You	O
could	O
use	O
`	O
mp.sharedctypes.RawArray	O
`	O
in	O
this	O
case	O
.	O

Beautiful	O
answer	O
!	O

If	O
I	O
want	O
to	O
have	O
more	O
than	O
one	O
shared	O
array	O
,	O
each	O
separately	O
lockable	O
,	O
but	O
with	O
the	O
number	O
of	O
arrays	O
determined	O
at	O
runtime	O
,	O
is	O
that	O
a	O
straightforward	O
extension	O
of	O
what	O
you've	O
done	O
here	O
?	O

@USER	O
:	O
shared	O
arrays	O
should	O
be	O
created	O
before	O
child	O
processes	O
are	O
spawned	O
.	O

Good	O
point	O
about	O
order	O
of	O
operations	O
.	O

That's	O
what	O
I	O
had	O
in	O
mind	O
,	O
though	O
:	O
create	O
a	O
user-specified	O
number	O
of	O
shared	O
arrays	O
,	O
then	O
spawn	O
a	O
few	O
child	O
processes	O
.	O

Is	O
that	O
straightforward	O
?	O

I've	O
made	O
another	O
question	O
to	O
deal	O
with	O
this	O
detail	O
:	O
stackoverflow.com/q/14416130/513688	O

@USER	O
:	O
you	O
can't	O
change	O
the	O
size	O
of	O
the	O
Array	O
.	O

Think	O
of	O
it	O
as	O
a	O
shared	O
block	O
of	O
memory	O
that	O
had	O
to	O
be	O
allocated	O
before	O
child	O
processes	O
are	O
started	O
.	O

You	O
don't	O
need	O
to	O
use	O
all	O
the	O
memory	O
e.g.	O
,	O
you	O
could	O
pass	O
`	O
count	B-API
`	O
to	O
`	O
numpy.frombuffer()	O
`	O
.	O

You	O
could	O
try	O
to	O
do	O
it	O
on	O
a	O
lower	O
level	O
using	O
`	O
mmap	O
`	O
or	O
something	O
like	O
`	O
posix_ipc	O
`	O
directly	O
to	O
implement	O
a	O
resizable	O
(	O
might	O
involve	O
copying	O
while	O
resizing	O
)	O
RawArray	O
analog	O
(	O
or	O
look	O
for	O
an	O
existing	O
library	O
)	O
.	O

Or	O
if	O
your	O
task	O
allows	O
it	O
:	O
copy	O
data	O
in	O
parts	O
(	O
if	O
you	O
don't	O
need	O
all	O
at	O
once	O
)	O
.	O

"	O
How	O
to	O
resize	O
a	O
shared	O
memory	O
"	O
is	O
a	O
good	O
separate	O
question	O
.	O

The	O
`	O
Array	O
`	O
object	O
has	O
a	O
`	O
get_obj()	O
`	O
method	O
associated	O
with	O
it	O
,	O
which	O
returns	O
the	O
ctypes	O
array	O
which	O
presents	O
a	O
buffer	O
interface	O
.	O

I	O
think	O
the	O
following	O
should	O
work	O
...	O

When	O
run	O
,	O
this	O
prints	O
out	O
the	O
first	O
element	O
of	O
`	O
a	O
`	O
now	O
being	O
10.0	O
,	O
showing	O
`	O
a	O
`	O
and	O
`	O
b	O
`	O
are	O
just	O
two	O
views	O
into	O
the	O
same	O
memory	O
.	O

In	O
order	O
to	O
make	O
sure	O
it	O
is	O
still	O
multiprocessor	O
safe	O
,	O
I	O
believe	O
you	O
will	O
have	O
to	O
use	O
the	O
`	O
acquire	O
`	O
and	O
`	O
release	O
`	O
methods	O
that	O
exist	O
on	O
the	O
`	O
Array	O
`	O
object	O
,	O
`	O
a	O
`	O
,	O
and	O
its	O
built	O
in	O
lock	O
to	O
make	O
sure	O
its	O
all	O
safely	O
accessed	O
(	O
though	O
I'm	O
not	O
an	O
expert	O
on	O
the	O
multiprocessor	O
module	O
)	O
.	O

it	O
won't	O
work	O
without	O
synchronization	O
as	O
@USER	O
demonstrated	O
in	O
his	O
(	O
now	O
deleted	O
)	O
answer	O
.	O

Presumably	O
,	O
if	O
you	O
just	O
wanted	O
to	O
access	O
the	O
array	O
post	O
processing	O
,	O
it	O
can	O
be	O
done	O
cleanly	O
without	O
worrying	O
about	O
concurrency	O
issues	O
and	O
locking	O
?	O

in	O
this	O
case	O
you	O
don't	O
need	O
`	O
mp.Array	O
`	O
.	O

The	O
processing	O
code	O
may	O
require	O
locked	O
arrays	O
,	O
but	O
the	O
post	O
processing	O
interpretation	O
of	O
the	O
data	O
might	O
not	O
necessarily	O
.	O

I	O
guess	O
this	O
comes	O
from	O
understanding	O
what	O
exactly	O
the	O
problem	O
is	O
.	O

Clearly	O
,	O
accessing	O
shared	O
data	O
concurrently	O
is	O
going	O
to	O
require	O
some	O
protection	O
,	O
which	O
I	O
thought	O
would	O
be	O
obvious	O
!	O

You	O
can	O
use	O
the	O
`	O
sharedmem	O
`	O
module	O
:	O
https://bitbucket.org/cleemesser/numpy-sharedmem	O

Here's	O
your	O
original	O
code	O
then	O
,	O
this	O
time	O
using	O
shared	O
memory	O
that	O
behaves	O
like	O
a	O
NumPy	O
array	O
(	O
note	O
the	O
additional	O
last	O
statement	O
calling	O
a	O
NumPy	O
`	O
sum()	O
`	O
function	O
):	O

Note	O
:	O
this	O
is	O
no	O
longer	O
being	O
developed	O
and	O
does	O
not	O
seem	O
to	O
work	O
on	O
linux	O
github.com/sturlamolden/sharedmem-numpy/issues/4	O

numpy-sharedmem	O
may	O
not	O
be	O
in	O
development	O
,	O
but	O
it	O
still	O
works	O
on	O
Linux	O
,	O
check	O
out	O
github.com/vmlaker/benchmark-sharedmem	O
.	O

I've	O
written	O
a	O
small	O
python	O
module	O
that	O
uses	O
POSIX	O
shared	O
memory	O
to	O
share	O
numpy	O
arrays	O
between	O
python	O
interpreters	O
.	O

Maybe	O
you	O
will	O
find	O
it	O
handy	O
.	O

https://pypi.python.org/pypi/SharedArray	O

Here's	O
how	O
it	O
works	O
:	O

While	O
the	O
answers	O
already	O
given	O
are	O
good	O
,	O
there	O
is	O
a	O
much	O
easier	O
solution	O
to	O
this	O
problem	O
provided	O
two	O
conditions	O
are	O
met	O
:	O

You	O
are	O
on	O
a	O
POSIX-compliant	O
operating	O
system	O
(	O
e.g.	O
Linux	O
,	O
Mac	O
OSX	O
);	O
and	O

Your	O
child	O
processes	O
need	O
read-only	O
access	O
to	O
the	O
shared	O
array	O
.	O

In	O
this	O
case	O
you	O
do	O
not	O
need	O
to	O
fiddle	O
with	O
explicitly	O
making	O
variables	O
shared	O
,	O
as	O
the	O
child	O
processes	O
will	O
be	O
created	O
using	O
a	O
fork	O
.	O

A	O
forked	O
child	O
automatically	O
shares	O
the	O
parent's	O
memory	O
space	O
.	O

In	O
the	O
context	O
of	O
Python	O
multiprocessing	O
,	O
this	O
means	O
it	O
shares	O
all	O
module-level	O
variables	O
;	O
note	O
that	O
this	O
does	O
not	O
hold	O
for	O
arguments	O
that	O
you	O
explicitly	O
pass	O
to	O
your	O
child	O
processes	O
or	O
to	O
the	O
functions	O
you	O
call	O
on	O
a	O
`	O
multiprocessing.Pool	O
`	O
or	O
so	O
.	O

A	O
simple	O
example	O
:	O

