Generate	O
a	O
heatmap	O
in	O
MatPlotLib	O
using	O
a	O
scatter	O
data	O
set	O

I	O
have	O
a	O
set	O
of	O
X	O
,	O
Y	O
data	O
points	O
(	O
about	O
10k	O
)	O
that	O
are	O
easy	O
to	O
plot	O
as	O
a	O
scatter	O
plot	O
but	O
that	O
I	O
would	O
like	O
to	O
represent	O
as	O
a	O
heatmap	O
.	O

I	O
looked	O
through	O
the	O
examples	O
in	O
MatPlotLib	O
and	O
they	O
all	O
seem	O
to	O
already	O
start	O
with	O
heatmap	O
cell	O
values	O
to	O
generate	O
the	O
image	O
.	O

Is	O
there	O
a	O
method	O
that	O
converts	O
a	O
bunch	O
of	O
x	O
,	O
y	O
,	O
all	O
different	O
,	O
to	O
a	O
heatmap	O
(	O
where	O
zones	O
with	O
higher	O
frequency	O
of	O
x	O
,	O
y	O
would	O
be	O
"	O
warmer	O
")	O
?	O

If	O
you	O
don't	O
want	O
hexagons	O
,	O
you	O
can	O
use	O
numpy's	O
`	O
histogram2d	O
`	O
function	O
:	O

This	O
makes	O
a	O
50x50	O
heatmap	O
.	O

If	O
you	O
want	O
,	O
say	O
,	O
512x384	O
,	O
you	O
can	O
put	O
`	O
bins	O
=(	O
512	O
,	O
384	O
)`	O
in	O
the	O
call	O
to	O
`	O
histogram2d	O
`	O
.	O

Example	O
:	O

I	O
don't	O
mean	O
to	O
be	O
an	O
idiot	O
,	O
but	O
how	O
do	O
you	O
actually	O
have	O
this	O
output	O
to	O
a	O
PNG	O
/	O
PDF	O
file	O
instead	O
of	O
only	O
displaying	O
in	O
an	O
interactive	O
IPython	O
session	O
?	O

I'm	O
trying	O
to	O
get	O
this	O
as	O
some	O
sort	O
of	O
normal	O
`	O
axes	B-API
`	O
instance	O
,	O
where	O
I	O
can	O
add	O
a	O
title	O
,	O
axis	O
labels	O
,	O
etc	O
.	O
and	O
then	O
do	O
the	O
normal	O
`	O
savefig()	O
`	O
like	O
I	O
would	O
do	O
for	O
any	O
other	O
typical	O
matplotlib	O
plot	O
.	O

@USER	O
:	O
doesn't	O
`	O
plt.savefig	O
(	O
'	O
filename.png	O
')`	O
work	O
?	O

If	O
you	O
want	O
to	O
get	O
an	O
axes	O
instance	O
,	O
use	O
Matplotlib's	O
object-oriented	O
interface	O
:	O
`	O
fig	O
=	O
plt.figure()	O
`	O
`	O
ax	O
=	O
fig.gca()	O
`	O
`	O
ax.imshow	O
(	O
...	O
)`	O
`	O
fig.savefig	O
(	O
...	O
)`	O

Indeed	O
,	O
thanks	O
!	O

I	O
guess	O
I	O
do	O
not	O
fully	O
understand	O
that	O
`	O
imshow()	O
`	O
is	O
on	O
the	O
same	O
category	O
of	O
functions	O
as	O
`	O
scatter()	O
`	O
.	O

I	O
honestly	O
don't	O
understand	O
why	O
`	O
imshow()	O
`	O
converts	O
a	O
2d	O
array	O
of	O
floats	O
into	O
blocks	O
of	O
appropriate	O
color	O
,	O
whereas	O
I	O
do	O
understand	O
what	O
`	O
scatter()	O
`	O
is	O
supposed	O
to	O
do	O
with	O
such	O
an	O
array	O
.	O

A	O
warning	O
about	O
using	O
imshow	O
for	O
plotting	O
a	O
2d	O
histogram	O
of	O
x	O
/	O
y	O
values	O
like	O
this	O
:	O
by	O
default	O
,	O
imshow	O
plots	O
the	O
origin	O
in	O
the	O
upper	O
left	O
corner	O
and	O
transposes	O
the	O
image	O
.	O

What	O
I	O
would	O
do	O
to	O
get	O
the	O
same	O
orientation	O
as	O
a	O
scatter	O
plot	O
is	O
`	O
plt.imshow	O
(	O
heatmap.T	O
,	O
extent=extent	O
,	O
origin	O
=	O
'	O
lower	O
')`	O

For	O
those	O
wanting	O
to	O
do	O
a	O
logarithmic	O
colorbar	O
see	O
this	O
question	O
stackoverflow.com/questions/17201172	O
and	O
simply	O
do	O
`	O
from	O
matplotlib.colors	O
import	O
LogNorm	O
`	O
`	O
plt.imshow	O
(	O
heatmap	O
,	O
norm=	O
LogNorm()	O
)`	O
`	O
plt.colorbar()	O
`	O

In	O
Matplotlib	O
lexicon	O
,	O
i	O
think	O
you	O
want	O
a	O
hexbin	O
plot	O
.	O

If	O
you're	O
not	O
familiar	O
with	O
this	O
type	O
of	O
plot	O
,	O
it's	O
just	O
a	O
bivariate	O
histogram	O
in	O
which	O
the	O
xy-plane	O
is	O
tessellated	O
by	O
a	O
regular	O
grid	O
of	O
hexagons	O
.	O

So	O
from	O
a	O
histogram	O
,	O
you	O
can	O
just	O
count	O
the	O
number	O
of	O
points	O
falling	O
in	O
each	O
hexagon	O
,	O
discretiize	O
the	O
plotting	O
region	O
as	O
a	O
set	O
of	O
windows	O
,	O
assign	O
each	O
point	O
to	O
one	O
of	O
these	O
windows	O
;	O
finally	O
,	O
map	B-API
the	O
windows	O
onto	O
a	O
color	O
array	O
,	O
and	O
you've	O
got	O
a	O
hexbin	O
diagram	O
.	O

Though	O
less	O
commonly	O
used	O
than	O
e.g.	O
,	O
circles	O
,	O
or	O
squares	O
,	O
that	O
hexagons	O
are	O
a	O
better	O
choice	O
for	O
the	O
geometry	O
of	O
the	O
binning	O
container	O
is	O
intuitive	O
:	O

hexagons	O
have	O
nearest-neighbor	O
symmetry	O
(	O
e.g.	O
,	O
square	O
bins	O
don't	O
,	O

e.g.	O
,	O
the	O
distance	O
from	O
a	O
point	O
on	O
a	O
square's	O
border	O
to	O
a	O
point	O

inside	O
that	O
square	O
is	O
not	O
everywhere	O
equal	O
)	O
and	O

hexagon	O
is	O
the	O
highest	O
n-polygon	O
that	O
gives	O
regular	O
plane	O

tessellation	O
(	O
i.e.	O
,	O
you	O
can	O
safely	O
re-model	O
your	O
kitchen	O
floor	O
with	O
hexagonal-shaped	O
tiles	O
because	O
you	O
won't	O
have	O
any	O
void	O
space	O
between	O
the	O
tiles	O
when	O
you	O
are	O
finished	O
--	O
not	O
true	O
for	O
all	O
other	O
higher-n	O
,	O
n	O
=	O
7	O
,	O
polygons	O
)	O
.	O

(	O
Matplotlib	O
uses	O
the	O
term	O
hexbin	O
plot	O
;	O
so	O
do	O
(	O
AFAIK	O
)	O
all	O
of	O
the	O
plotting	O
libraries	O
for	O
R	O
;	O
still	O
i	O
don't	O
know	O
if	O
this	O
is	O
the	O
generally	O
accepted	O
term	O
for	O
plots	O
of	O
this	O
type	O
,	O
though	O
i	O
suspect	O
it's	O
likely	O
given	O
that	O
hexbin	O
is	O
short	O
for	O
hexagonal	O
binning	O
,	O
which	O
is	O
describes	O
the	O
essential	O
step	O
in	O
preparing	O
the	O
data	O
for	O
display	O
.	O

)	O

What	O
does	O
it	O
mean	O
that	O
"	O
hexagons	O
have	O
nearest-neighbor	O
symmetry	O
"	O
?	O

You	O
say	O
that	O
"	O
the	O
distance	O
from	O
a	O
point	O
on	O
a	O
square's	O
border	O
and	O
a	O
point	O
inside	O
that	O
square	O
is	O
not	O
everywhere	O
equal	O
"	O
but	O
distance	O
to	O
what	O
?	O

For	O
a	O
hexagon	O
,	O
the	O
distance	O
from	O
center	O
to	O
a	O
vertex	O
joining	O
two	O
sides	O
is	O
also	O
longer	O
than	O
from	O
center	O
to	O
middle	O
of	O
a	O
side	O
,	O
only	O
the	O
ratio	O
is	O
smaller	O
(	O
2	O
/	O
sqrt	O
(	O
3	O
)	O
1.15	O
for	O
hexagon	O
vs	O
.	O
sqrt	O
(	O
2	O
)	O
1.41	O
for	O
square	O
)	O
.	O

The	O
only	O
shape	O
where	O
the	O
distance	O
from	O
the	O
center	O
to	O
every	O
point	O
on	O
the	O
border	O
is	O
equal	O
is	O
the	O
circle	O
.	O

@USER	O
For	O
a	O
hexagon	O
,	O
every	O
neighbor	O
is	O
at	O
the	O
same	O
distance	O
.	O

There	O
is	O
no	O
issue	O
with	O
8-neighborhood	O
or	O
4-neighborhood	O
.	O

No	O
diagonal	O
neighbors	O
,	O
just	O
one	O
kind	O
of	O
neighbor	O
.	O

@USER	O
How	O
do	O
you	O
choose	O
the	O
`	O
gridsize=	O
`	O
parameter	O
.	O

I	O
would	O
like	O
to	O
choose	O
it	O
such	O
,	O
so	O
that	O
the	O
hexagons	O
just	O
touch	O
without	O
overlapping	O
.	O

I	O
noticed	O
that	O
`	O
gridsize=100	O
`	O
would	O
produce	O
smaller	O
hexagons	O
,	O
but	O
how	O
to	O
choose	O
the	O
proper	O
value	O
?	O

Instead	O
of	O
using	O
np.hist2d	O
,	O
which	O
in	O
general	O
produces	O
quite	O
ugly	O
histograms	O
,	O
I	O
would	O
like	O
to	O
recycle	O
py-sphviewer	O
,	O
a	O
python	O
package	O
for	O
rendering	O
particle	O
simulations	O
using	O
an	O
adaptive	O
smoothing	O
kernel	O
and	O
that	O
can	O
be	O
easily	O
installed	O
from	O
pip	O
(	O
see	O
webpage	O
documentation	O
)	O
.	O

Consider	O
the	O
following	O
code	O
,	O
which	O
is	O
based	O
on	O
the	O
example	O
:	O

which	O
produces	O
the	O
following	O
image	O
:	O

As	O
you	O
see	O
,	O
the	O
images	O
look	O
pretty	O
nice	O
,	O
and	O
we	O
are	O
able	O
to	O
identify	O
different	O
substructures	O
on	O
it	O
.	O

These	O
images	O
are	O
constructed	O
spreading	O
a	O
given	O
weight	O
for	O
every	O
point	O
within	O
a	O
certain	O
domain	O
,	O
defined	O
by	O
the	O
smoothing	O
length	O
,	O
which	O
in	O
turns	O
is	O
given	O
by	O
the	O
distance	O
to	O
the	O
closer	O
nb	O
neighbor	O
(	O
I've	O
chosen	O
16	O
,	O
32	O
and	O
64	O
for	O
the	O
examples	O
)	O
.	O

So	O
,	O
higher	O
density	O
regions	O
typically	O
are	O
spread	O
over	O
smaller	O
regions	O
compared	O
to	O
lower	O
density	O
regions	O
.	O

The	O
function	O
myplot	O
is	O
just	O
a	O
very	O
simple	O
function	O
that	O
I've	O
written	O
in	O
order	O
to	O
give	O
the	O
x	O
,	O
y	O
data	O
to	O
py-sphviewer	O
to	O
do	O
the	O
magic	O
.	O

A	O
comment	O
for	O
anyone	O
trying	O
to	O
install	O
py-sphviewer	O
on	O
OSX	O
:	O
I	O
had	O
quite	O
a	O
lot	O
of	O
difficulty	O
,	O
see	O
:	O
github.com/alejandrobll/py-sphviewer/issues/3	O

If	O
you	O
are	O
using	O
1.2.x	O

Seaborn	O
now	O
has	O
the	O
jointplot	O
function	O
which	O
should	O
work	O
nicely	O
here	O
:	O

Simple	O
,	O
pretty	O
and	O
analytically	O
useful	O
.	O

@USER	O
how	O
do	O
you	O
make	O
a	O
600k	O
data	O
visually	O
readable	O
using	O
this	O
?	O

(	O
how	O
to	O
resize	O
)	O

I'm	O
not	O
quite	O
sure	O
what	O
you	O
mean	O
;	O
maybe	O
it's	O
best	O
you	O
ask	O
a	O
separate	O
question	O
and	O
link	O
it	O
here	O
.	O

You	O
mean	O
resize	O
the	O
whole	O
fig	O
?	O

First	O
make	O
the	O
figure	O
with	O
`	O
fig	O
=	O
plt.figure	O
(	O
figsize	O
=(	O
12	O
,	O
12	O
))`	O
,	O
then	O
get	O
the	O
current	O
axis	O
with	O
`	O
ax	O
=p	O
lt.gca()	O
`	O
,	O
then	O
add	O
the	O
argument	O
`	O
ax=ax	O
`	O
to	O
the	O
`	O
jointplot	O
`	O
function	O
.	O

Make	O
a	O
2-dimensional	O
array	O
that	O
corresponds	O
to	O
the	O
cells	O
in	O
your	O
final	O
image	O
,	O
called	O
say	O
`	O
heatmap_cells	O
`	O
and	O
instantiate	O
it	O
as	O
all	O
zeroes	O
.	O

Choose	O
two	O
scaling	O
factors	O
that	O
define	O
the	O
difference	O
between	O
each	O
array	O
element	O
in	O
real	O
units	O
,	O
for	O
each	O
dimension	O
,	O
say	O
`	O
x_scale	O
`	O
and	O
`	O
y_scale	O
`	O
.	O

Choose	O
these	O
such	O
that	O
all	O
your	O
datapoints	O
will	O
fall	O
within	O
the	O
bounds	O
of	O
the	O
heatmap	O
array	O
.	O

For	O
each	O
raw	O
datapoint	O
with	O
`	O
x_value	O
`	O
and	O
`	O
y_value	O
`	O
:	O

`	O
heatmap_cells	O
[	O
floor	O
(	O
x_value	O
/	O
x_scale	O
)	O
,	O
floor	O
(	O
y_value	O
/	O
y_scale	O
)]	O
+=1	O
`	O

Numpy	O
has	O
a	O
function	O
for	O
that	O
...	O

