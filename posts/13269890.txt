cartesian product in pandas
I have two pandas dataframes :
What is the best practice to get their cartesian product ( of course without writing it explicitly like me ) ?
You have a typo in DataFrame for df2 . I can't edit because it's less than 6 characters .
@USER For similar problem in the future : put spaces somewhere . It works
@USER so obvious ! Thanks , should have thought of it myself .
If you have a key that is repeated for each row , then you can produce a cartesian product using merge ( like you would in SQL ) .
See here for the documentation : http://pandas.pydata.org/pandas-docs/stable/merging.html#brief-primer-on-merge-methods-relational-algebra
i hoped that there is cleaner API rather then adding column , but it does the job , thanks
This won't win a code golf competition , and borrows from the previous answers - but clearly shows how the key is added , and how the join works . This creates 2 new data frames from lists , then adds the key to do the cartesian product on .
My use case was that I needed a list of all store IDs on for each week in my list . So , I created a list of all the weeks I wanted to have , then a list of all the store IDs I wanted to map them against .
The merge I chose left , but would be semantically the same as inner in this setup . You can see this in the documentation on merging , which states it does a Cartesian product if key combination appears more than once in both tables - which is what we set up .
A bit shorter version : ` days_and_stores = pd.merge ( days.assign ( key=0 ) , stores.assign ( key=0 ) , on= ' key ') .drop ( ' key ' , axis=1 )`
You mention crossJoin , but you are using a pandas dataframe , not a spark dataframe .
Dang . Wasn't thinking . I use spark + pandas together so often , that when I saw the update to spark I thought about this post . Thanks Bryce .
As an alternative , one can rely on the cartesian product provided by itertools : ` itertools.product ` , which avoids creating a temporary key or modifying the index :
Quick test :
If you have no overlapping columns , don't want to add one , and the indices of the data frames can be discarded , this may be easier :
This looks promising - but I get the error on the first line : ` TypeError : ' class ' pandas.core.index.Int64Index ' ' does not support mutable operations . ` I can get around this by adding ` , index =[ 0 , 0 ]` to the dataframe definition though .
Or using ` df1 = df1.set_index ([[ 0 ] *len ( df1 )]))` ( and similarly for ` df2 `) .
Racing Tadpole's edits made this work for me - thanks !