How to iterate over rows in a DataFrame in Pandas ?
I have a DataFrames from pandas :
Output :
Now I want to iterate over the rows of the above frame . For every row I want to be able to access its elements ( values in cells ) by the name of the columns . So , for example , I would like to have something like that :
Is it possible to do that in pandas ?
I found similar question . But it does not give me the answer I need . For example , it is suggested there to use :
or
But I do not understand what the ` row ` object is and how I can work with it .
Possible duplicate of What is the most efficient way to loop through dataframes with pandas ?
Possible duplicate of add one row in a pandas.DataFrame
iterrows is a generator which yield both index and row
Note : " Because iterrows returns a Series for each row , it does not preserve dtypes across the rows . " Also , " You should never modify something you are iterating over . " According to pandas 0.19.1 docs
While ` iterrows() ` is a good option , sometimes ` itertuples() ` can be much faster :
Much of the time difference in your two examples seems like it is due to the fact that you appear to be using label-based indexing for the .iterrows() command and integer-based indexing for the .itertuples() command .
For a finance data based dataframe ( timestamp , and 4x float ) , itertuples is 19 , 57 times faster then iterrows on my machine . Only ` for a , b , c in izip ( df [ " a "] , df [ " b "] , df [ " c "] : ` is almost equally fast .
Can you explain why it's faster ?
@USER ` iterrows() ` boxes each row of data into a Series , whereas ` itertuples() ` does not .
You can also use ` df.apply() ` to iterate over rows and access multiple columns for a function .
docs : DataFrame.apply()
Is the df [ ' price '] refers to a column name in the data frame ? I am trying to create a dictionary with unique values from several columns in a csv file . I used your logic to create a dictionary with unique keys and values and got an error stating TypeError : ( "' Series ' objects are mutable , thus they cannot be hashed " , u'occurred at index 0 ')
Code : df [ ' Workclass '] = df.apply ( lambda row : dic_update ( row ) , axis=1 ) end of line id = 0 end of line def dic_update ( row ): if row not in dic : dic [ row ] = id id = id + 1
Never mind , I got it . Changed the function call line to df_new = df [ ' Workclass '] .apply ( same thing )
To iterate through DataFrame's row in pandas way one can use :
DataFrame.iterrows()
` for index , row in df.iterrows() :
print row [ " c1 "] , row [ " c2 "]
`
DataFrame.itertuples()
` for row in df.itertuples ( index=True , name= ' Pandas ') :
print getattr ( row , " c1 ") , getattr ( row , " c2 ")
`
` itertuples() ` is supposed to be faster than ` iterrows() `
But be aware , according to the docs ( pandas 0.19.1 at the moment ):
iterrows : data's ` dtype ` might not match from row to row
Because iterrows returns a Series for each row , it does not preserve dtypes across the rows ( dtypes are preserved across columns for DataFrames )
*
iterrows : Do not modify rows
You should never modify something you are iterating over . This is not guaranteed to work in all cases . Depending on the data types , the iterator returns a copy and not a view , and writing to it will have no effect .
Use DataFrame.apply() instead :
` new_df = df.apply ( lambda x : x * 2 )
`
itertuples :
The column names will be renamed to positional names if they are invalid Python identifiers , repeated , or start with an underscore . With a large number of columns ( 255 ) , regular tuples are returned .
You can use the df.iloc function as follows :
Using ` 0 ` in ` range ` is pointless , you can omit it .
To loop all rows in a ` dataframe ` you can use :
Use itertuples() . It is faster than iterrows() :
Using ` iterrows ` which return a generator that iterates over the rows of the frame
for more detail on iterrows