How to apply a function to two columns of Pandas dataframe
Suppose I have a ` df ` which has columns of `' ID ' , ' col_1 ' , ' col_2 '` . And I define a function :
` f = lambda x , y : my_function_expression ` .
Now I want to apply the ` f ` to ` df `' s two columns `' col_1 ' , ' col_2 '` to element-wise calculate a new column `' col_3 '` , somewhat like :
How to do ?
** Add detail sample as below ***
can you apply f directly to columns : df [ ' col_3 '] = f ( df [ ' col_1 '] , df [ ' col_2 '])
would be useful to know what ` f ` is doing
no , df [ ' col_3 '] = f ( df [ ' col_1 '] , df [ ' col_2 ']) not work . For f only accepts scalar input , not vector inputs . OK , you can assume f = lambda x , y : x+y . ( of course , my real f is not that simple , otherwise i can directly df [ ' col_3 '] = df [ ' col_1 '] + df [ ' col_2 '] )
I found a related Q A at below url , but my issue is calculating a new column by two existing columns , not 2 from 1 . stackoverflow.com/questions/12356501
Here's an example using ` apply ` on the dataframe , which I am calling with ` axis = 1 ` .
Note the difference is that instead of trying to pass two values to the function ` f ` , rewrite the function to accept a pandas Series object , and then index the Series to get the values needed .
Depending on your use case , it is sometimes helpful to create a pandas ` group ` object , and then use ` apply ` on the group .
Yes , i tried to use apply , but can't find the valid syntax expression . And if each row of df is unique , still use groupby ?
Added an example to my answer , hope this does what you're looking for . If not , please provide a more specific example function since ` sum ` is solved successfully by any of the methods suggested so far .
i provide a detail sample in question . How to use Pandas ' apply ' function to create ' col_3 ' ?
Would you pls paste your code ? I rewrite the function : def get_sublist ( x ): return mylist [ x [ 1 ]: x [ 2 ] + 1 ] and df [ ' col_3 '] = df.apply ( get_sublist , axis=1 ) gives ' ValueError : operands could not be broadcast together with shapes ( 2 ) ( 3 )'
@USER : with Pandas version 0.14.1 ( and possibly earlier ) , use can use a lambda expression as well . Give the ` df ` object you defined , another approach ( with equivalent results ) is ` df.apply ( lambda x : x [ 0 ] + x [ 1 ] , axis = 1 )` .
A interesting question ! my answer as below :
Output :
I changed the column name to ID , J1 , J2 , J3 to ensure ID J1 J2 J3 , so the column display in right sequence .
One more brief version :
A simple solution is :
how is this answer different to the approach in thequestion : df [ ' col_3 '] = df [[ ' col_1 ' , ' col_2 ']] .apply ( f ) just to confirm , the approach in the question didn't work because the poster did not specify this axis=1 , the default is axis = 0 ?
The method you are looking for is Series.combine .
However , it seems some care has to be taken around datatypes .
In your example , you would ( as I did when testing the answer ) naively call
However , this throws the error :
My best guess is that it seems to expect the result to be of the same type as the series calling the method ( df.col_1 here ) . However , the following works :
With my quirky function , this actually worked !!
The way you have written f it needs two inputs . If you look at the error message it says you are not providing two inputs to f , just one . The error message is correct .
The mismatch is because df [[ ' col1 ' , ' col2 ']] returns a single dataframe with two columns , not two separate columns .
You need to change your f so that it takes a single input , keep the above data frame as input , then break it up into x , y inside the function body . Then do whatever you need and return a single value .
You need this function signature because the syntax is .apply ( f )
So f needs to take the single thing = dataframe and not two things which is what your current f expects .
Since you haven't provided the body of f I can't help in anymore detail - but this should provide the way out without fundamentally changing your code or using some other methods rather than apply
I'm going to put in a vote for np.vectorize . It allows you to just shoot over x number of columns and not deal with the dataframe in the function , so it's great for functions you don't control or doing something like sending 2 columns and a constant into a function ( i.e. col_1 , col_2 , ' foo ') .
This doesn't really answer the question using pandas .
The question is " How to apply a function to two columns of Pandas dataframe " not " How to apply a function to two columns of Pandas dataframe using only Pandas methods " and numpy is a dependency of Pandas so you have to have it installed anyway , so this seems like a strange objection .
I'm sure this isn't as fast as the solutions using Pandas or Numpy operations , but if you don't want to rewrite your function you can use map . Using the original example data -
We could pass as many arguments as we wanted into the function this way . The output is what we wanted
My example to your questions :