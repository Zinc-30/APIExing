Generate a heatmap in MatPlotLib using a scatter data set
I have a set of X , Y data points ( about 10k ) that are easy to plot as a scatter plot but that I would like to represent as a heatmap .
I looked through the examples in MatPlotLib and they all seem to already start with heatmap cell values to generate the image .
Is there a method that converts a bunch of x , y , all different , to a heatmap ( where zones with higher frequency of x , y would be " warmer ") ?
If you don't want hexagons , you can use numpy's ` histogram2d ` function :
This makes a 50x50 heatmap . If you want , say , 512x384 , you can put ` bins =( 512 , 384 )` in the call to ` histogram2d ` .
Example :
I don't mean to be an idiot , but how do you actually have this output to a PNG / PDF file instead of only displaying in an interactive IPython session ? I'm trying to get this as some sort of normal ` axes ` instance , where I can add a title , axis labels , etc . and then do the normal ` savefig() ` like I would do for any other typical matplotlib plot .
@USER : doesn't ` plt.savefig ( ' filename.png ')` work ? If you want to get an axes instance , use Matplotlib's object-oriented interface : ` fig = plt.figure() ` ` ax = fig.gca() ` ` ax.imshow ( ... )` ` fig.savefig ( ... )`
Indeed , thanks ! I guess I do not fully understand that ` imshow() ` is on the same category of functions as ` scatter() ` . I honestly don't understand why ` imshow() ` converts a 2d array of floats into blocks of appropriate color , whereas I do understand what ` scatter() ` is supposed to do with such an array .
A warning about using imshow for plotting a 2d histogram of x / y values like this : by default , imshow plots the origin in the upper left corner and transposes the image . What I would do to get the same orientation as a scatter plot is ` plt.imshow ( heatmap.T , extent=extent , origin = ' lower ')`
For those wanting to do a logarithmic colorbar see this question stackoverflow.com/questions/17201172 and simply do ` from matplotlib.colors import LogNorm ` ` plt.imshow ( heatmap , norm= LogNorm() )` ` plt.colorbar() `
In Matplotlib lexicon , i think you want a hexbin plot .
If you're not familiar with this type of plot , it's just a bivariate histogram in which the xy-plane is tessellated by a regular grid of hexagons .
So from a histogram , you can just count the number of points falling in each hexagon , discretiize the plotting region as a set of windows , assign each point to one of these windows ; finally , map the windows onto a color array , and you've got a hexbin diagram .
Though less commonly used than e.g. , circles , or squares , that hexagons are a better choice for the geometry of the binning container is intuitive :
hexagons have nearest-neighbor symmetry ( e.g. , square bins don't ,
e.g. , the distance from a point on a square's border to a point
inside that square is not everywhere equal ) and
hexagon is the highest n-polygon that gives regular plane
tessellation ( i.e. , you can safely re-model your kitchen floor with hexagonal-shaped tiles because you won't have any void space between the tiles when you are finished -- not true for all other higher-n , n = 7 , polygons ) .
( Matplotlib uses the term hexbin plot ; so do ( AFAIK ) all of the plotting libraries for R ; still i don't know if this is the generally accepted term for plots of this type , though i suspect it's likely given that hexbin is short for hexagonal binning , which is describes the essential step in preparing the data for display . )
What does it mean that " hexagons have nearest-neighbor symmetry " ? You say that " the distance from a point on a square's border and a point inside that square is not everywhere equal " but distance to what ?
For a hexagon , the distance from center to a vertex joining two sides is also longer than from center to middle of a side , only the ratio is smaller ( 2 / sqrt ( 3 ) 1.15 for hexagon vs . sqrt ( 2 ) 1.41 for square ) . The only shape where the distance from the center to every point on the border is equal is the circle .
@USER For a hexagon , every neighbor is at the same distance . There is no issue with 8-neighborhood or 4-neighborhood . No diagonal neighbors , just one kind of neighbor .
@USER How do you choose the ` gridsize= ` parameter . I would like to choose it such , so that the hexagons just touch without overlapping . I noticed that ` gridsize=100 ` would produce smaller hexagons , but how to choose the proper value ?
Instead of using np.hist2d , which in general produces quite ugly histograms , I would like to recycle py-sphviewer , a python package for rendering particle simulations using an adaptive smoothing kernel and that can be easily installed from pip ( see webpage documentation ) . Consider the following code , which is based on the example :
which produces the following image :
As you see , the images look pretty nice , and we are able to identify different substructures on it . These images are constructed spreading a given weight for every point within a certain domain , defined by the smoothing length , which in turns is given by the distance to the closer nb neighbor ( I've chosen 16 , 32 and 64 for the examples ) . So , higher density regions typically are spread over smaller regions compared to lower density regions .
The function myplot is just a very simple function that I've written in order to give the x , y data to py-sphviewer to do the magic .
A comment for anyone trying to install py-sphviewer on OSX : I had quite a lot of difficulty , see : github.com/alejandrobll/py-sphviewer/issues/3
If you are using 1.2.x
Seaborn now has the jointplot function which should work nicely here :
Simple , pretty and analytically useful .
@USER how do you make a 600k data visually readable using this ? ( how to resize )
I'm not quite sure what you mean ; maybe it's best you ask a separate question and link it here . You mean resize the whole fig ? First make the figure with ` fig = plt.figure ( figsize =( 12 , 12 ))` , then get the current axis with ` ax =p lt.gca() ` , then add the argument ` ax=ax ` to the ` jointplot ` function .
Make a 2-dimensional array that corresponds to the cells in your final image , called say ` heatmap_cells ` and instantiate it as all zeroes .
Choose two scaling factors that define the difference between each array element in real units , for each dimension , say ` x_scale ` and ` y_scale ` . Choose these such that all your datapoints will fall within the bounds of the heatmap array .
For each raw datapoint with ` x_value ` and ` y_value ` :
` heatmap_cells [ floor ( x_value / x_scale ) , floor ( y_value / y_scale )] +=1 `
Numpy has a function for that ...