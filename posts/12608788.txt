Changing the “tick frequency” on x or y axis in matplotlib ?
I am trying to fix how python plots my data .
Say
and
Then I would do :
and the x axis ' ticks are plotted in intervals of 5 . Is there a way to make it show intervals of 1 ?
Though ticks is the appropriate word here , change ticks to step size will definitely guide more newbies to this question .
Closely related question : stackoverflow.com/questions/6682784 and a great solution : ` pyplot.locator_params ( nbins=4 )`
@USER -PhilipGehrcke Thank you so goddamn much !
You could explicitly set where you want to tick marks with ` plt.xticks ` :
For example ,
( ` np.arange ` was used rather than Python's ` range ` function just in case ` min ( x )` and ` max ( x )` are floats instead of ints . )
The ` plt.plot ` ( or ` ax.plot `) function will automatically set default ` x ` and ` y ` limits . If you wish to keep those limits , and just change the stepsize of the tick marks , then you could use ` ax.get_xlim() ` to discover what limits Matplotlib has already set .
The default tick formatter should do a decent job rounding the tick values to a sensible number of significant digits . However , if you wish to have more control over the format , you can define your own formatter . For example ,
Here's a runnable example :
Is there no way to get it to still decide it's own limits , but just change the step size ? This method is not very good if the min is something like 3523.232512 !
@USER , It has been a while since you asked , but I have posted an answer below that allows for easy control of step size while still using automatic bounds determination .
Note that the ` +1 ` in ` plt.xticks ( np.arange ( min ( x ) , max ( x ) +1 , 1.0 ))` is required to show the last tick mark .
Yes , ` np.arange ( start , stop )` generates values in the half-open interval ` [ start , stop )` , including ` start ` but excluding ` stop ` . So I used ` max ( x ) +1 ` to ensure that ` max ( x )` is included .
Another approach is to set the axis locator :
There are several different types of locator depending upon your needs .
This does not work as expected . Specifically , when using dates , it does not use the appropriate dates .
When using dates , you should use the methods in the matplotlib.dates module . For example ` matplotlib.dates.AutoDateLocator() `
This should be the accepted solution .
It worked as expected for me , with dates . This solution is much easier than the accepted one .
I like this solution ( from the Matplotlib Plotting Cookbook ):
This solution give you explicit control of the tick spacing via the number given to ` ticker.MultipleLocater() ` , allows automatic limit determination , and is easy to read later .
A way to do this without calculating the ticks explicitly !
This is the same answer as this one . It does not make sense to add an identical answer two years later .
Good catch . I did not recognize them as the same when I posted the answer . Still , I think this presentation is a little easier to understand .
In case anyone is interested in a general one-liner , simply get the current ticks and use it to set the new ticks by sampling every other tick .
This is a bit hacky , but by far the cleanest / easiest to understand example that I've found to do this . It's from an answer on SO here :
Cleanest way to hide every nth tick label in matplotlib colorbar ?
Then you can loop over the labels setting them to visible or not depending on the density you want .
edit : note that sometimes matplotlib sets labels == `''` , so it might look like a label is not present , when in fact it is and just isn't displaying anything . To make sure you're looping through actual visible labels , you could try :
This is the most simple and generic solution . A tiny adjustment : usually ` ax.get_xticklabels() [ 1 :: 2 ]` are the labels to be hidden .
This doesn't work with matplotlib.finance.candlestick2
@USER it could be that some of the xticklabels are just set to `''` so that when you loop through them , you're making xticklabels that are empty invisible ( which would have no effect on the visualization , but might mean that you aren't pulling the correct labels ) . You could try : ` vis_labels = [ label for label in ax.get_xticklabels() if label.get_visible() is True ]; plt.setp ( vis_labels [: : 2 ] , visible == False )`
This is an old topic , but I stumble over this every now and then and made this function . It's very convenient :
One caveat of controlling the ticks like this is that one does no longer enjoy the interactive automagic updating of max scale after an added line . Then do
and run the resadjust function again .
I developed an inelegant solution . Consider that we have the X axis and also a list of labels for each point in X .
Example :
Let's say that I want to show ticks labels only for ' feb ' and ' jun '
Good , now we have a fake list of labels . First , we plotted the original version .
Now , the modified version .
This worked for me
if you want ticks between [ 1 , 5 ] ( 1 and 5 inclusive ) then replace
fyi , you could simply write ` xmarks = range ( 1 , length+1 , 1 )` . pretty sure the list comprehension is redundant .
Here's a pure python implementation of the desired functionality that handles any numeric series ( int or float ) with positive , negative , or mixed values :
Sample Output :
And Sample Usage :