Pandas : Drop consecutive duplicates
What's the most efficient way to drop only consecutive duplicates in pandas ?
drop_duplicates gives this :
But I want this :
Use shift :
So the above uses boolean critieria , we compare the dataframe against the dataframe shifted by -1 rows to create the mask
Another method is to use ` diff ` :
But this is slower than the original method if you have a large number of rows .
Update
Thanks to Bjarke Ebert for pointing out a subtle error , I should actually use ` shift ( 1 )` or just ` shift() ` as the default is a period of 1 , this returns the first consecutive value :
Note the difference in index values , thanks @USER !
I had the same problem and google'd to find this question . And wow , what a nice and simple solution ! :-D
but hm , you may want to say a.loc [ a.shift ( 1 ) ! = a ] , in order to get the first of the consecutive values , as specified in the question :-)
@USER no worries , glad to help , I noted your comment and you are correct , the resulting row values was what the OP wanted but the index values were the wrong rows as you correctly potined out , interestingly using ` diff ` was slower for a 50k series , probably due to the value comparison
Also , ` df.col ! = df.col.shift() ` is much more general . Using ` diff ` only works for integers whereas ` shift ` works for floats , strings , etc .
@USER You'd have to do ` a.loc [( a.notnull() ) ( a.shift() ! = a )]` to handle the ` NaN ` rows
Here is an update that will make it work with multiple columns . Use " .any ( axis=1 )" to combine the results from each column :
this seem to cause a KeyError
Can you add a bit more context ?