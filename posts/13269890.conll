cartesian	O
product	O
in	O
pandas	O

I	O
have	O
two	O
pandas	O
dataframes	O
:	O

What	O
is	O
the	O
best	O
practice	O
to	O
get	O
their	O
cartesian	O
product	O
(	O
of	O
course	O
without	O
writing	O
it	O
explicitly	O
like	O
me	O
)	O
?	O

You	O
have	O
a	O
typo	O
in	O
DataFrame	B-API
for	O
df2	O
.	O

I	O
can't	O
edit	O
because	O
it's	O
less	O
than	O
6	O
characters	O
.	O

@USER	O
For	O
similar	O
problem	O
in	O
the	O
future	O
:	O
put	O
spaces	O
somewhere	O
.	O

It	O
works	O

@USER	O
so	O
obvious	O
!	O

Thanks	O
,	O
should	O
have	O
thought	O
of	O
it	O
myself	O
.	O

If	O
you	O
have	O
a	O
key	O
that	O
is	O
repeated	O
for	O
each	O
row	O
,	O
then	O
you	O
can	O
produce	O
a	O
cartesian	O
product	O
using	O
merge	B-API
(	O
like	O
you	O
would	O
in	O
SQL	O
)	O
.	O

See	O
here	O
for	O
the	O
documentation	O
:	O
http://pandas.pydata.org/pandas-docs/stable/merging.html#brief-primer-on-merge-methods-relational-algebra	O

i	O
hoped	O
that	O
there	O
is	O
cleaner	O
API	O
rather	O
then	O
adding	O
column	O
,	O
but	O
it	O
does	O
the	O
job	O
,	O
thanks	O

This	O
won't	O
win	O
a	O
code	O
golf	O
competition	O
,	O
and	O
borrows	O
from	O
the	O
previous	O
answers	O
-	O
but	O
clearly	O
shows	O
how	O
the	O
key	O
is	O
added	O
,	O
and	O
how	O
the	O
join	B-API
works	O
.	O

This	O
creates	O
2	O
new	O
data	O
frames	O
from	O
lists	O
,	O
then	O
adds	O
the	O
key	O
to	O
do	O
the	O
cartesian	O
product	O
on	O
.	O

My	O
use	O
case	O
was	O
that	O
I	O
needed	O
a	O
list	O
of	O
all	O
store	O
IDs	O
on	O
for	O
each	O
week	O
in	O
my	O
list	O
.	O

So	O
,	O
I	O
created	O
a	O
list	O
of	O
all	O
the	O
weeks	O
I	O
wanted	O
to	O
have	O
,	O
then	O
a	O
list	O
of	O
all	O
the	O
store	O
IDs	O
I	O
wanted	O
to	O
map	B-API
them	O
against	O
.	O

The	O
merge	B-API
I	O
chose	O
left	O
,	O
but	O
would	O
be	O
semantically	O
the	O
same	O
as	O
inner	O
in	O
this	O
setup	O
.	O

You	O
can	O
see	O
this	O
in	O
the	O
documentation	O
on	O
merging	O
,	O
which	O
states	O
it	O
does	O
a	O
Cartesian	O
product	O
if	O
key	O
combination	O
appears	O
more	O
than	O
once	O
in	O
both	O
tables	O
-	O
which	O
is	O
what	O
we	O
set	O
up	O
.	O

A	O
bit	O
shorter	O
version	O
:	O
`	O
days_and_stores	O
=	O
pd.merge	B-API
(	O
days.assign	O
(	O
key=0	O
)	O
,	O
stores.assign	O
(	O
key=0	O
)	O
,	O
on=	O
'	O
key	O
')	O
.drop	B-API
(	O
'	O
key	O
'	O
,	O
axis=1	O
)`	O

You	O
mention	O
crossJoin	O
,	O
but	O
you	O
are	O
using	O
a	O
pandas	O
dataframe	B-API
,	O
not	O
a	O
spark	O
dataframe	B-API
.	O

Dang	O
.	O

Wasn't	O
thinking	O
.	O

I	O
use	O
spark	O
+	O
pandas	O
together	O
so	O
often	O
,	O
that	O
when	O
I	O
saw	O
the	O
update	O
to	O
spark	O
I	O
thought	O
about	O
this	O
post	O
.	O

Thanks	O
Bryce	O
.	O

As	O
an	O
alternative	O
,	O
one	O
can	O
rely	O
on	O
the	O
cartesian	O
product	O
provided	O
by	O
itertools	O
:	O
`	O
itertools.product	O
`	O
,	O
which	O
avoids	O
creating	O
a	O
temporary	O
key	O
or	O
modifying	O
the	O
index	O
:	O

Quick	O
test	O
:	O

If	O
you	O
have	O
no	O
overlapping	O
columns	O
,	O
don't	O
want	O
to	O
add	O
one	O
,	O
and	O
the	O
indices	O
of	O
the	O
data	O
frames	O
can	O
be	O
discarded	O
,	O
this	O
may	O
be	O
easier	O
:	O

This	O
looks	O
promising	O
-	O
but	O
I	O
get	O
the	O
error	O
on	O
the	O
first	O
line	O
:	O
`	O
TypeError	O
:	O
'	O
class	O
'	O
pandas.core.index.Int64Index	O
'	O
'	O
does	O
not	O
support	O
mutable	O
operations	O
.	O

`	O
I	O
can	O
get	O
around	O
this	O
by	O
adding	O
`	O
,	O
index	O
=[	O
0	O
,	O
0	O
]`	O
to	O
the	O
dataframe	B-API
definition	O
though	O
.	O

Or	O
using	O
`	O
df1	O
=	O
df1.set_index	O
([[	O
0	O
]	O
*len	O
(	O
df1	O
)]))`	O
(	O
and	O
similarly	O
for	O
`	O
df2	O
`)	O
.	O

Racing	O
Tadpole's	O
edits	O
made	O
this	O
work	O
for	O
me	O
-	O
thanks	O
!	O

