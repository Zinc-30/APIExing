Changing	O
the	O
“tick	O
frequency”	O
on	O
x	O
or	O
y	O
axis	O
in	O
matplotlib	O
?	O

I	O
am	O
trying	O
to	O
fix	O
how	O
python	O
plots	O
my	O
data	O
.	O

Say	O

and	O

Then	O
I	O
would	O
do	O
:	O

and	O
the	O
x	O
axis	O
'	O
ticks	O
are	O
plotted	O
in	O
intervals	O
of	O
5	O
.	O

Is	O
there	O
a	O
way	O
to	O
make	O
it	O
show	O
intervals	O
of	O
1	O
?	O

Though	O
ticks	O
is	O
the	O
appropriate	O
word	O
here	O
,	O
change	O
ticks	O
to	O
step	O
size	O
will	O
definitely	O
guide	O
more	O
newbies	O
to	O
this	O
question	O
.	O

Closely	O
related	O
question	O
:	O
stackoverflow.com/questions/6682784	O
and	O
a	O
great	O
solution	O
:	O
`	O
pyplot.locator_params	O
(	O
nbins=4	O
)`	O

@USER	O
-PhilipGehrcke	O
Thank	O
you	O
so	O
goddamn	O
much	O
!	O

You	O
could	O
explicitly	O
set	O
where	O
you	O
want	O
to	O
tick	O
marks	O
with	O
`	O
plt.xticks	O
`	O
:	O

For	O
example	O
,	O

(	O
`	O
np.arange	O
`	O
was	O
used	O
rather	O
than	O
Python's	O
`	O
range	O
`	O
function	O
just	O
in	O
case	O
`	O
min	O
(	O
x	O
)`	O
and	O
`	O
max	O
(	O
x	O
)`	O
are	O
floats	O
instead	O
of	O
ints	O
.	O
)	O

The	O
`	O
plt.plot	O
`	O
(	O
or	O
`	O
ax.plot	O
`)	O
function	O
will	O
automatically	O
set	O
default	O
`	O
x	O
`	O
and	O
`	O
y	O
`	O
limits	O
.	O

If	O
you	O
wish	O
to	O
keep	O
those	O
limits	O
,	O
and	O
just	O
change	O
the	O
stepsize	O
of	O
the	O
tick	O
marks	O
,	O
then	O
you	O
could	O
use	O
`	O
ax.get_xlim()	O
`	O
to	O
discover	O
what	O
limits	O
Matplotlib	O
has	O
already	O
set	O
.	O

The	O
default	O
tick	O
formatter	O
should	O
do	O
a	O
decent	O
job	O
rounding	O
the	O
tick	O
values	O
to	O
a	O
sensible	O
number	O
of	O
significant	O
digits	O
.	O

However	O
,	O
if	O
you	O
wish	O
to	O
have	O
more	O
control	O
over	O
the	O
format	O
,	O
you	O
can	O
define	O
your	O
own	O
formatter	O
.	O

For	O
example	O
,	O

Here's	O
a	O
runnable	O
example	O
:	O

Is	O
there	O
no	O
way	O
to	O
get	O
it	O
to	O
still	O
decide	O
it's	O
own	O
limits	O
,	O
but	O
just	O
change	O
the	O
step	O
size	O
?	O

This	O
method	O
is	O
not	O
very	O
good	O
if	O
the	O
min	O
is	O
something	O
like	O
3523.232512	O
!	O

@USER	O
,	O
It	O
has	O
been	O
a	O
while	O
since	O
you	O
asked	O
,	O
but	O
I	O
have	O
posted	O
an	O
answer	O
below	O
that	O
allows	O
for	O
easy	O
control	O
of	O
step	O
size	O
while	O
still	O
using	O
automatic	O
bounds	O
determination	O
.	O

Note	O
that	O
the	O
`	O
+1	O
`	O
in	O
`	O
plt.xticks	O
(	O
np.arange	O
(	O
min	O
(	O
x	O
)	O
,	O
max	O
(	O
x	O
)	O
+1	O
,	O
1.0	O
))`	O
is	O
required	O
to	O
show	O
the	O
last	O
tick	O
mark	O
.	O

Yes	O
,	O
`	O
np.arange	O
(	O
start	O
,	O
stop	O
)`	O
generates	O
values	O
in	O
the	O
half-open	O
interval	O
`	O
[	O
start	O
,	O
stop	O
)`	O
,	O
including	O
`	O
start	O
`	O
but	O
excluding	O
`	O
stop	O
`	O
.	O

So	O
I	O
used	O
`	O
max	O
(	O
x	O
)	O
+1	O
`	O
to	O
ensure	O
that	O
`	O
max	O
(	O
x	O
)`	O
is	O
included	O
.	O

Another	O
approach	O
is	O
to	O
set	O
the	O
axis	O
locator	O
:	O

There	O
are	O
several	O
different	O
types	O
of	O
locator	O
depending	O
upon	O
your	O
needs	O
.	O

This	O
does	O
not	O
work	O
as	O
expected	O
.	O

Specifically	O
,	O
when	O
using	O
dates	O
,	O
it	O
does	O
not	O
use	O
the	O
appropriate	O
dates	O
.	O

When	O
using	O
dates	O
,	O
you	O
should	O
use	O
the	O
methods	O
in	O
the	O
matplotlib.dates	O
module	O
.	O

For	O
example	O
`	O
matplotlib.dates.AutoDateLocator()	O
`	O

This	O
should	O
be	O
the	O
accepted	O
solution	O
.	O

It	O
worked	O
as	O
expected	O
for	O
me	O
,	O
with	O
dates	O
.	O

This	O
solution	O
is	O
much	O
easier	O
than	O
the	O
accepted	O
one	O
.	O

I	O
like	O
this	O
solution	O
(	O
from	O
the	O
Matplotlib	O
Plotting	O
Cookbook	O
):	O

This	O
solution	O
give	O
you	O
explicit	O
control	O
of	O
the	O
tick	O
spacing	O
via	O
the	O
number	O
given	O
to	O
`	O
ticker.MultipleLocater()	O
`	O
,	O
allows	O
automatic	O
limit	O
determination	O
,	O
and	O
is	O
easy	O
to	O
read	O
later	O
.	O

A	O
way	O
to	O
do	O
this	O
without	O
calculating	O
the	O
ticks	O
explicitly	O
!	O

This	O
is	O
the	O
same	O
answer	O
as	O
this	O
one	O
.	O

It	O
does	O
not	O
make	O
sense	O
to	O
add	O
an	O
identical	O
answer	O
two	O
years	O
later	O
.	O

Good	O
catch	O
.	O

I	O
did	O
not	O
recognize	O
them	O
as	O
the	O
same	O
when	O
I	O
posted	O
the	O
answer	O
.	O

Still	O
,	O
I	O
think	O
this	O
presentation	O
is	O
a	O
little	O
easier	O
to	O
understand	O
.	O

In	O
case	O
anyone	O
is	O
interested	O
in	O
a	O
general	O
one-liner	O
,	O
simply	O
get	O
the	O
current	O
ticks	O
and	O
use	O
it	O
to	O
set	O
the	O
new	O
ticks	O
by	O
sampling	O
every	O
other	O
tick	O
.	O

This	O
is	O
a	O
bit	O
hacky	O
,	O
but	O
by	O
far	O
the	O
cleanest	O
/	O
easiest	O
to	O
understand	O
example	O
that	O
I've	O
found	O
to	O
do	O
this	O
.	O

It's	O
from	O
an	O
answer	O
on	O
SO	O
here	O
:	O

Cleanest	O
way	O
to	O
hide	O
every	O
nth	O
tick	O
label	O
in	O
matplotlib	O
colorbar	O
?	O

Then	O
you	O
can	O
loop	O
over	O
the	O
labels	O
setting	O
them	O
to	O
visible	O
or	O
not	O
depending	O
on	O
the	O
density	O
you	O
want	O
.	O

edit	O
:	O
note	O
that	O
sometimes	O
matplotlib	O
sets	O
labels	O
==	O
`''`	O
,	O
so	O
it	O
might	O
look	O
like	O
a	O
label	O
is	O
not	O
present	O
,	O
when	O
in	O
fact	O
it	O
is	O
and	O
just	O
isn't	O
displaying	O
anything	O
.	O

To	O
make	O
sure	O
you're	O
looping	O
through	O
actual	O
visible	O
labels	O
,	O
you	O
could	O
try	O
:	O

This	O
is	O
the	O
most	O
simple	O
and	O
generic	O
solution	O
.	O

A	O
tiny	O
adjustment	O
:	O
usually	O
`	O
ax.get_xticklabels()	O
[	O
1	O
::	O
2	O
]`	O
are	O
the	O
labels	O
to	O
be	O
hidden	O
.	O

This	O
doesn't	O
work	O
with	O
matplotlib.finance.candlestick2	O

@USER	O
it	O
could	O
be	O
that	O
some	O
of	O
the	O
xticklabels	O
are	O
just	O
set	O
to	O
`''`	O
so	O
that	O
when	O
you	O
loop	O
through	O
them	O
,	O
you're	O
making	O
xticklabels	O
that	O
are	O
empty	O
invisible	O
(	O
which	O
would	O
have	O
no	O
effect	O
on	O
the	O
visualization	O
,	O
but	O
might	O
mean	O
that	O
you	O
aren't	O
pulling	O
the	O
correct	O
labels	O
)	O
.	O

You	O
could	O
try	O
:	O
`	O
vis_labels	O
=	O
[	O
label	O
for	O
label	O
in	O
ax.get_xticklabels()	O
if	O
label.get_visible()	O
is	O
True	O
];	O
plt.setp	O
(	O
vis_labels	O
[:	O
:	O
2	O
]	O
,	O
visible	O
==	O
False	O
)`	O

This	O
is	O
an	O
old	O
topic	O
,	O
but	O
I	O
stumble	O
over	O
this	O
every	O
now	O
and	O
then	O
and	O
made	O
this	O
function	O
.	O

It's	O
very	O
convenient	O
:	O

One	O
caveat	O
of	O
controlling	O
the	O
ticks	O
like	O
this	O
is	O
that	O
one	O
does	O
no	O
longer	O
enjoy	O
the	O
interactive	O
automagic	O
updating	O
of	O
max	O
scale	O
after	O
an	O
added	O
line	O
.	O

Then	O
do	O

and	O
run	O
the	O
resadjust	O
function	O
again	O
.	O

I	O
developed	O
an	O
inelegant	O
solution	O
.	O

Consider	O
that	O
we	O
have	O
the	O
X	O
axis	O
and	O
also	O
a	O
list	O
of	O
labels	O
for	O
each	O
point	O
in	O
X	O
.	O

Example	O
:	O

Let's	O
say	O
that	O
I	O
want	O
to	O
show	O
ticks	O
labels	O
only	O
for	O
'	O
feb	O
'	O
and	O
'	O
jun	O
'	O

Good	O
,	O
now	O
we	O
have	O
a	O
fake	O
list	O
of	O
labels	O
.	O

First	O
,	O
we	O
plotted	O
the	O
original	O
version	O
.	O

Now	O
,	O
the	O
modified	O
version	O
.	O

This	O
worked	O
for	O
me	O

if	O
you	O
want	O
ticks	O
between	O
[	O
1	O
,	O
5	O
]	O
(	O
1	O
and	O
5	O
inclusive	O
)	O
then	O
replace	O

fyi	O
,	O
you	O
could	O
simply	O
write	O
`	O
xmarks	O
=	O
range	O
(	O
1	O
,	O
length+1	O
,	O
1	O
)`	O
.	O
pretty	O
sure	O
the	O
list	O
comprehension	O
is	O
redundant	O
.	O

Here's	O
a	O
pure	O
python	O
implementation	O
of	O
the	O
desired	O
functionality	O
that	O
handles	O
any	O
numeric	O
series	O
(	O
int	O
or	O
float	O
)	O
with	O
positive	O
,	O
negative	O
,	O
or	O
mixed	O
values	O
:	O

Sample	O
Output	O
:	O

And	O
Sample	O
Usage	O
:	O

