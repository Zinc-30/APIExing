Matplotlib 2 Subplots , 1 Colorbar
I've spent entirely too long researching how to get two subplots to share the same y-axis with a single colorbar shared between the two in Matplotlib .
What was happening was that when I called the ` colorbar() ` function in either ` subplot1 ` or ` subplot2 ` , it would autoscale the plot such that the colorbar plus the plot would fit inside the ' subplot ' bounding box , causing the two side-by-side plots to be two very different sizes .
To get around this , I tried to create a third subplot which I then hacked to render no plot with just a colorbar present .
The only problem is , now the heights and widths of the two plots are uneven , and I can't figure out how to make it look okay .
Here is my code :
Just place the colorbar in its own axis and use ` subplots_adjust ` to make room for it .
As a quick example :
Awesome ! Thanks so much for the help .
ImageGrid is also very useful for this exact purpose .
if you need to use tight_layout() , you will want to do everything after subplots_adjust after tight_layout , and then tweak the coordinates for subplots_adjust and add_axes manually .
How can I have a single color bar for two different scatter plots that I already have ? I tried above but I don't know how to substitute " im " with appropriate variables . Let say my scatter plots are plot1 =p ylib.scatter ( x , y , z ) and plot2 =p ylib.scatter ( a , b , c )
This may have been obvious to others , but I wanted to point out that in order that the colourbar does accurately represent the colour in all the plots , the ` vmin ` and ` vmax ` arguments are critical . They control the colour range of each subplot . If you have real data , you may need to do a pass through this to find the min and max values first .
You can simplify Joe Kington's code using the ` ax ` parameter of ` figure.colorbar() ` with a list of axes .
From the documentation :
ax
None | parent axes object ( s ) from which space for a new colorbar axes will be stolen . If a list of axes is given they will all be resized to make room for the colorbar axes .
This solution worked very well here , and seems to be the easiest one .
If you change nrows to 1 , both plots are shoter than colorbar . so , how can solve this problem ?
Pity it doesn't work with tight_layout , but good solution nonetheless .
Using ` make_axes ` is even easier and gives a better result . It also provides possibilities to customise the positioning of the colorbar .
Also note the option of ` subplots ` to share x and y axes .
This method does not work when the subplot is not square . If you change ` nrows=1 ` , the colorbar becomes larger than the subplots again .
This solution does not require manual tweaking of axes locations or colorbar size , works with multi-row and single-row layouts , and works with ` tight_layout() ` . It is adapted from a gallery example , using ` ImageGrid ` from matplotlib's AxesGrid Toolbox .
Double +1 , this is a great approach
Indeed works with tight_layout , but I have no idea how to add a label to that colorbar . It doesn't accept the kws label , title , text ... anything ! And the docs don't help much .
@USER To set a label , you can grab the colorbar's handle when you instantiate it , as : ` thecb = ax.cax.colorbar ( im )` . Then you can do ` thecb.set_label_text ( " foo ")`
Can you show how to use this ` rect ` parameter ?
@USER The ` rect ` parameter specifies the bounding box of the figure elements with the figure area . It takes normalized figure co-ords and the default is ` [ 0 , 0 , 1 , 1 ]` . So specifying ` rect =[ 0 , 0 , 0.9 , 1 ]` as an argument to ` tight_layout ` would force the figure elements that tight_layout knows about to fit within 90% of the figure width , leaving 10% for your label . See doc .
The solution of using a list of axes by abevieiramota works very well until you use only one row of images , as pointed out in the comments . Using a reasonable aspect ratio for ` figsize ` helps , but is still far from perfect . For example :
The colorbar function provides the ` shrink ` parameter which is a scaling factor for the size of the colorbar axes . It does require some manual trial and error . For example :
As a beginner who stumbled across this thread , I'd like to add a python-for-dummies adaptation of abevieiramota ' s very neat answer ( because I'm at the level that I had to look up ' ravel ' to work out what their code was doing ):
Much less pythonic , much easier for noobs like me to see what's actually happening here .
As pointed out in other answers , the idea is usually to define an axes for the colorbar to reside in . There are various ways of doing so ; one that hasn't been mentionned yet would be to directly specify the colorbar axes at subplot creation with ` plt.subplots() ` . The advantage is that the axes position does not need to be manually set and in all cases with automatic aspect the colorbar will be exactly the same height as the subplots . Even in many cases where images are used the result will be satisfying as shown below .
When using ` plt.subplots() ` , the use of ` gridspec_kw ` argument allows to make the colorbar axes much smaller than the other axes .
Example :
This works well , if the plots ' aspect is autoscaled or the images are shrunk due to their aspect in the width direction ( as in the above ) . If , however , the images are wider then high , the result would look as follows , which might be undesired .
A solution to fix the colorbar height to the subplot height would be to use ` mpl_toolkits.axes_grid1.inset_locator.InsetPosition ` to set the colorbar axes relative to the image subplot axes .