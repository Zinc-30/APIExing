Python , Pandas : Use the GroupBy.groups description to apply it to another grouping
Let's consider a DataFrame that contains 1 row of 2 values per each day of the month of Jan 2010 :
I split that DataFrame into a list of 5 DataFrames , each of them containing 1 week worth of data from the original : ` df_weeks = [ g for n , g in df.groupby ( pd.TimeGrouper ( ' W '))]`
If I type ` df.groupby ( pd.TimeGrouper ( ' W ')) .groups ` I can see a dict explaining how the groups are split :
Let's consider another TimeSerie that has sparser data yet overlaps with the first one :
If I run the same code ` obs_weeks = [ g for n , g in observations.groupby ( pd.TimeGrouper ( ' W '))]` , obviously it will returns less DataFrames in the list , as the data covers less span . ` observations.groupby ( pd.TimeGrouper ( ' W ')) .groups ` returns :
But would there be a way to reuse the groups of the first DataFrame.GroupBy to apply it to the second one ? i.e. that would mean in that specific case ending up with a variable ` obs_weeks ` containing 5 DataFrames spanning the same time range as ` df_weeks ` , 2 of them being empty ?
One simple solution to your problem would be to make sure the observations dataframe contains all the dates that the df dataframe does . You can do this with the ` reindex ` method . You will then have the exact same groups . You can also use ` resample ( ' W ')` instead of ` groupby ( pd.Timegrouper ( ' W '))`
And if we do a simple aggregation like sum we can see the results of both frames
And now with ` obs2 ` which has 2 missing groups
Thanks a lot for your answer . However I am receiving the following error message when trying ` observations.reindex ( df )` : ` ValueError : The truth value of an array with more than one element is ambiguous . Use a.any() or a.all() `
I am using a slightly different dataset for ` observations ` with dates 1 8/ 01 , 20 / 01 , 22 / 01 , 2 8/ 01 , but I would assume this should still work .
Apologies . I meant df.index . it's corrected now