find	O
length	O
of	O
sequences	O
of	O
identical	O
values	O
in	O
a	O
numpy	O
array	O

In	O
a	O
pylab	O
program	O
(	O
which	O
could	O
probably	O
be	O
a	O
matlab	O
program	O
as	O
well	O
)	O
I	O
have	O
a	O
numpy	O
array	O
of	O
numbers	O
representing	O
distances	O
:	O
`	O
d	O
[	O
t	B-API
]`	O
is	O
the	O
distance	O
at	O
time	O
`	O
t	B-API
`	O
(	O
and	O
the	O
timespan	O
of	O
my	O
data	O
is	O
`	O
len	O
(	O
d	O
)`	O
time	O
units	O
)	O
.	O

The	O
events	O
I'm	O
interested	O
in	O
are	O
when	O
the	O
distance	O
is	O
below	O
a	O
certain	O
threshold	O
,	O
and	O
I	O
want	O
to	O
compute	O
the	O
duration	O
of	O
these	O
events	O
.	O

It's	O
easy	O
to	O
get	O
an	O
array	O
of	O
booleans	O
with	O
`	O
b	O
=	O
d	O
threshold	O
`	O
,	O
and	O
the	O
problem	O
comes	O
down	O
to	O
computing	O
the	O
sequence	O
of	O
the	O
lengths	O
of	O
the	O
True-only	O
words	O
in	O
`	O
b	O
`	O
.	O

But	O
I	O
do	O
not	O
know	O
how	O
to	O
do	O
that	O
efficiently	O
(	O
i.e.	O
using	O
numpy	O
primitives	O
)	O
,	O
and	O
I	O
resorted	O
to	O
walk	O
the	O
array	O
and	O
to	O
do	O
manual	O
change	O
detection	O
(	O
i.e.	O
initialize	O
counter	O
when	O
value	O
goes	O
from	O
False	O
to	O
True	O
,	O
increase	O
counter	O
as	O
long	O
as	O
value	O
is	O
True	O
,	O
and	O
output	O
the	O
counter	O
to	O
the	O
sequence	O
when	O
value	O
goes	O
back	O
to	O
False	O
)	O
.	O

But	O
this	O
is	O
tremendously	O
slow	O
.	O

How	O
to	O
efficienly	O
detect	O
that	O
sort	O
of	O
sequences	O
in	O
numpy	O
arrays	O
?	O

Below	O
is	O
some	O
python	O
code	O
that	O
illustrates	O
my	O
problem	O
:	O
the	O
fourth	O
dot	O
takes	O
a	O
very	O
long	O
time	O
to	O
appear	O
(	O
if	O
not	O
,	O
increase	O
the	O
size	O
of	O
the	O
array	O
)	O

While	O
not	O
`	O
numpy	O
`	O
primitives	O
,	O
`	O
itertools	O
`	O
functions	O
are	O
often	O
very	O
fast	O
,	O
so	O
do	O
give	O
this	O
one	O
a	O
try	O
(	O
and	O
measure	O
times	O
for	O
various	O
solutions	O
including	O
this	O
one	O
,	O
of	O
course	O
):	O

If	O
you	O
do	O
need	O
the	O
values	O
in	O
a	O
list	O
,	O
just	O
can	O
use	O
list	O
(	O
runs_of_ones	O
(	O
bits	O
))	O
,	O
of	O
course	O
;	O
but	O
maybe	O
a	O
list	O
comprehension	O
might	O
be	O
marginally	O
faster	O
still	O
:	O

Moving	O
to	O
"	O
numpy-native	O
"	O
possibilities	O
,	O
what	O
about	O
:	O

Again	O
:	O
be	O
sure	O
to	O
benchmark	O
solutions	O
against	O
each	O
others	O
in	O
realistic-for-you	O
examples	O
!	O

Hmmmmm	O
...	O
that	O
last	O
one	O
looks	O
familiar	O
.	O

;)	O

Thanks	O
a	O
lot	O
!	O

The	O
diff	B-API
/	O
where	O
solution	O
is	O
exactly	O
what	O
I	O
had	O
in	O
mind	O
(	O
not	O
to	O
mention	O
it	O
is	O
about	O
10	O
times	O
faster	O
than	O
the	O
other	O
solutions	O
)	O
.	O

Call	O
that	O
"	O
not	O
too	O
clever	O
"	O
if	O
you	O
like	O
,	O
but	O
I	O
wish	O
I	O
was	O
clever	O
enough	O
to	O
come	O
up	O
with	O
it	O
:-)	O

@USER	O
,	O
I	O
don't	O
do	O
matlab	O
(	O
funny	O
enough	O
my	O
daughter	O
,	O
now	O
a	O
PhD	O
candidate	O
in	O
advanced	O
radio	O
engineering	O
,	O
does	O
;-)	O
,	O
but	O
now	O
looking	O
at	O
your	O
answer	O
I	O
do	O
see	O
the	O
analogies	O
--	O
get	O
the	O
end-of-runs	O
minus	O
the	O
start-of-runs	O
,	O
get	O
those	O
by	O
locating	O
0	O
and	O
0	O
spot	O
in	O
the	O
differences	O
,	O
and	O
pad	O
the	O
bits	O
with	O
zeros	O
to	O
make	O
sure	O
all	O
runs-of-ones	O
do	O
end	O
.	O

Guess	O
there	O
aren't	O
that	O
many	O
ways	O
to	O
skin	O
this	O
"	O
run	O
lengths	O
"	O
problem	O
!	O

-	O
)	O

@USER	O
,	O
you're	O
welcome	O
--	O
as	O
@USER	O
hints	O
,	O
the	O
matlab	O
solution	O
is	O
also	O
similar	O
,	O
or	O
so	O
I	O
guess	O
it	O
would	O
be	O
if	O
one	O
knew	O
matlab	O
--	O
so	O
it	O
must	O
be	O
that	O
neither	O
is	O
very	O
clever	O
;-)	O
...	O

it's	O
more	O
a	O
question	O
of	O
having	O
had	O
to	O
do	O
run-length	O
coding	O
stuff	O
before	O
(	O
most	O
of	O
the	O
time	O
in	O
my	O
edit	O
was	O
about	O
translating	O
from	O
Numeric	O
,	O
which	O
is	O
what	O
I	O
still	O
tend	O
instinctively	O
to	O
turn	O
to	O
,	O
to	O
much-better	O
numpy	O
--	O
but	O
where	O
I	O
actually	O
first	O
learned	O
such	O
things	O
was	O
with	O
APL	O
,	O
30	O
years	O
ago	O
,	O
when	O
I	O
was	O
still	O
a	O
hardware	O
designer	O
...!	O
-	O
)	O
.	O

Fully	O
numpy	O
vectorized	O
and	O
generic	O
RLE	O
for	O
any	O
array	O
(	O
works	O
with	O
strings	O
,	O
booleans	O
etc	O
too	O
)	O
.	O

Outputs	O
tuple	O
of	O
run	O
lengths	O
,	O
start	O
positions	O
,	O
and	O
values	O
.	O

Pretty	O
fast	O
(	O
i7	O
):	O

Multiple	O
data	O
types	O
:	O

Same	O
results	O
as	O
Alex	O
Martelli	O
above	O
:	O

Slightly	O
slower	O
than	O
Alex	O
(	O
but	O
still	O
very	O
fast	O
)	O
,	O
and	O
much	O
more	O
flexible	O
.	O

This	O
one's	O
a	O
beaut	O
,	O
thankyou	O
for	O
sharing	O
.	O

Just	O
in	O
case	O
anyone	O
is	O
curious	O
(	O
and	O
since	O
you	O
mentioned	O
MATLAB	O
in	O
passing	O
)	O
,	O
here's	O
one	O
way	O
to	O
solve	O
it	O
in	O
MATLAB	O
:	O

I'm	O
not	O
too	O
familiar	O
with	O
Python	O
,	O
but	O
maybe	O
this	O
could	O
help	O
give	O
you	O
some	O
ideas	O
.	O

=)	O

thanks	O
for	O
this	O
answer	O
as	O
well	O
,	O
this	O
is	O
exactly	O
the	O
kind	O
of	O
stuff	O
I	O
was	O
looking	O
for	O

diff()	B-API
exists	O
in	O
numpy	O
too	O
,	O
so	O
this	O
is	O
more	O
or	O
less	O
what	O
you	O
want	O
though	O
replace	O
find	O
(	O
foo	O
)	O
with	O
where	O
(	O
foo	O
)	O
[	O
0	O
]	O
.	O

Here	O
is	O
a	O
solution	O
using	O
only	O
arrays	O
:	O
it	O
takes	O
an	O
array	O
containing	O
a	O
sequence	O
of	O
bools	O
and	O
counts	O
the	O
length	O
of	O
the	O
transitions	O
.	O

`	O
sw	O
`	O
contains	O
a	O
true	O
where	O
there	O
is	O
a	O
switch	O
,	O
`	O
isw	O
`	O
converts	O
them	O
in	O
indexes	O
.	O

The	O
items	O
of	O
isw	O
are	O
then	O
subtracted	O
pairwise	O
in	O
`	O
lens	O
`	O
.	O

Notice	O
that	O
if	O
the	O
sequence	O
started	O
with	O
an	O
1	O
it	O
would	O
count	O
the	O
length	O
of	O
the	O
0s	O
sequences	O
:	O
this	O
can	O
be	O
fixed	O
in	O
the	O
indexing	O
to	O
compute	O
lens	O
.	O

Also	O
,	O
I	O
have	O
not	O
tested	O
corner	O
cases	O
such	O
sequences	O
of	O
length	O
1	O
.	O

Full	O
function	O
that	O
returns	O
start	O
positions	O
and	O
lengths	O
of	O
all	O
`	O
True	O
`	O
-subarrays	O
.	O

Tested	O
for	O
different	O
bool	O
1D-arrays	O
(	O
empty	O
array	O
;	O
single	O
/	O
multiple	O
elements	O
;	O
even	O
/	O
odd	O
lengths	O
;	O
started	O
with	O
`	O
True	O
`	O
/	O
`	O
False	O
`	O
;	O
with	O
only	O
`	O
True	O
`	O
/	O
`	O
False	O
`	O
elements	O
)	O
.	O

sure	O
,	O
this	O
is	O
more	O
consise	O
,	O
but	O
just	O
as	O
inefficient	O
;	O
what	O
I	O
want	O
to	O
do	O
is	O
move	O
the	O
loop	O
down	O
to	O
the	O
C	O
layer	O
,	O
by	O
means	O
of	O
using	O
some	O
clever	O
combination	O
of	O
numpy	O
calls	O
...	O

check	O
my	O
edited	O
answer	O
,	O
I	O
now	O
offer	O
one	O
such	O
"	O
clever	O
combinations	O
"	O
(	O
always	O
trying	O
hard	O
not	O
to	O
be	O
TOO	O
clever	O
though	O
;-)	O
--	O
but	O
,	O
do	O
measure	O
the	O
speed	O
of	O
that	O
one	O
AND	O
the	O
itertools.groupby-based	O
solution	O
,	O
and	O
let	O
us	O
know	O
which	O
one	O
is	O
faster	O
(	O
and	O
by	O
how	O
much	O
)	O
in	O
examples	O
realistic-for-you	O
!	O

