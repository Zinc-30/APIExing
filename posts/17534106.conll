What	O
is	O
the	O
difference	O
between	O
NaN	O
and	O
None	O
?	O

I	O
am	O
reading	O
two	O
columns	O
of	O
a	O
csv	O
file	O
using	O
pandas	O
`	O
readcsv()	O
`	O
and	O
then	O
assigning	O
the	O
values	O
to	O
a	O
dictionary	O
.	O

The	O
columns	O
contain	O
strings	O
of	O
numbers	O
and	O
letters	O
.	O

Occasionally	O
there	O
are	O
cases	O
where	O
a	O
cell	O
is	O
empty	O
.	O

In	O
my	O
opinion	O
,	O
the	O
value	O
read	O
to	O
that	O
dictionary	O
entry	O
should	O
be	O
`	O
None	O
`	O
but	O
instead	O
`	O
nan	O
`	O
is	O
assigned	O
.	O

Surely	O
`	O
None	O
`	O
is	O
more	O
descriptive	O
of	O
an	O
empty	O
cell	O
as	O
it	O
has	O
a	O
null	O
value	O
,	O
whereas	O
`	O
nan	O
`	O
just	O
says	O
that	O
the	O
value	O
read	O
is	O
not	O
a	O
number	O
.	O

Is	O
my	O
understanding	O
correct	O
,	O
what	O
IS	O
the	O
difference	O
between	O
`	O
None	O
`	O
and	O
`	O
nan	O
`	O
?	O

Why	O
is	O
`	O
nan	O
`	O
assigned	O
instead	O
of	O
`	O
None	O
`	O
?	O

Also	O
,	O
my	O
dictionary	O
check	O
for	O
any	O
empty	O
cells	O
has	O
been	O
using	O
`	O
numpy.isnan()	O
`	O
:	O

But	O
this	O
gives	O
me	O
an	O
error	O
saying	O
that	O
I	O
cannot	O
use	O
this	O
check	O
for	O
`	O
v	O
`	O
.	O

I	O
guess	O
it	O
is	O
because	O
an	O
integer	O
or	O
float	O
variable	O
,	O
not	O
a	O
string	O
is	O
meant	O
to	O
be	O
used	O
.	O

If	O
this	O
is	O
true	O
,	O
how	O
can	O
I	O
check	O
`	O
v	O
`	O
for	O
an	O
"	O
empty	O
cell	O
"	O
/	O
`	O
nan	O
`	O
case	O
?	O

The	O
text	O
`	O
qwerty	O
`	O
is	O
not	O
a	O
number	O
.	O

@USER	O
I	O
know	O
,	O
so	O
surely	O
`	O
None	O
`	O
would	O
be	O
a	O
better	O
description	O
of	O
the	O
value	O
of	O
an	O
empty	O
cell	O
.	O

@USER	O
my	O
answer	O
describes	O
that	O

NaN	O
is	O
used	O
as	O
a	O
placeholder	O
for	O
missing	O
data	O
consistently	O
in	O
pandas	O
,	O
consistency	O
is	O
good	O
.	O

I	O
usually	O
read	O
/	O
translate	B-API
NaN	O
as	O
"	O
missing	O
"	O
.	O

Also	O
see	O
the	O
'	O
working	O
with	O
missing	O
data	O
'	O
section	O
in	O
the	O
docs	O
.	O

Wes	O
writes	O
in	O
the	O
docs	O
'	O
choice	O
of	O
NA-representation	O
'	O
:	O

After	O
years	O
of	O
production	O
use	O
[	O
NaN	O
]	O
has	O
proven	O
,	O
at	O
least	O
in	O
my	O
opinion	O
,	O
to	O
be	O
the	O
best	O
decision	O
given	O
the	O
state	O
of	O
affairs	O
in	O
NumPy	O
and	O
Python	O
in	O
general	O
.	O

The	O
special	O
value	O
NaN	O
(	O
Not-A-Number	O
)	O
is	O
used	O
everywhere	O
as	O
the	O
NA	O
value	O
,	O
and	O
there	O
are	O
API	O
functions	O
`	O
isnull	B-API
`	O
and	O
`	O
notnull	B-API
`	O
which	O
can	O
be	O
used	O
across	O
the	O
dtypes	B-API
to	O
detect	O
NA	O
values	O
.	O

...	O

Thus	O
,	O
I	O
have	O
chosen	O
the	O
Pythonic	O
practicality	O
beats	O
purity	O
approach	O
and	O
traded	O
integer	O
NA	O
capability	O
for	O
a	O
much	O
simpler	O
approach	O
of	O
using	O
a	O
special	O
value	O
in	O
float	O
and	O
object	O
arrays	O
to	O
denote	O
NA	O
,	O
and	O
promoting	O
integer	O
arrays	O
to	O
floating	O
when	O
NAs	O
must	O
be	O
introduced	O
.	O

Note	O
:	O
the	O
"	O
gotcha	O
"	O
that	O
integer	O
Series	O
containing	O
missing	O
data	O
are	O
upcast	O
to	O
floats	O
.	O

In	O
my	O
opinion	O
the	O
main	O
reason	O
to	O
use	O
NaN	O
(	O
over	O
None	O
)	O
is	O
that	O
it	O
can	O
be	O
stored	O
with	O
numpy's	O
float64	O
dtype	B-API
,	O
rather	O
than	O
the	O
less	O
efficient	O
object	O
dtype	B-API
,	O
see	O
NA	O
type	O
promotions	O
.	O

Jeff	O
comments	O
(	O
below	O
)	O
on	O
this	O
:	O

`	O
np.nan	O
`	O
allows	O
for	O
vectorized	O
operations	O
;	O
its	O
a	O
float	O
value	O
,	O
while	O
`	O
None	O
`	O
,	O
by	O
definition	O
,	O
forces	O
object	O
type	O
,	O
which	O
basically	O
disables	O
all	O
efficiency	O
in	O
numpy	O
.	O

So	O
repeat	O
3	O
times	O
fast	O
:	O
object	O
==	O
bad	O
,	O
float	O
==	O
good	O

Saying	O
that	O
,	O
many	O
operations	O
may	O
still	O
work	O
just	O
as	O
well	O
with	O
None	O
vs	O
NaN	O
(	O
but	O
perhaps	O
are	O
not	O
supported	O
i.e.	O
they	O
may	O
sometimes	O
give	O
surprising	O
results	O
):	O

To	O
answer	O
the	O
second	O
question	O
:	O

You	O
should	O
be	O
using	O
`	O
pd.isnull	B-API
`	O
and	O
`	O
pd.notnull	B-API
`	O
to	O
test	O
for	O
missing	O
data	O
(	O
NaN	O
)	O
.	O

just	O
adding	O
2c	O
here	O
....	O

`	O
np.nan	O
`	O
allows	O
for	O
vectorized	O
operations	O
;	O
its	O
a	O
float	O
value	O
,	O
while	O
`	O
None	O
`	O
by	O
definition	O
forces	O
`	O
object	O
`	O
type	O
,	O
and	O
basically	O
disables	O
all	O
efficiency	O
in	O
numpy	O
,	O
so	O
repeat	O
3	O
times	O
fast	O
:	O
`	O
object	O
==	O
bad	O
,	O
float	O
==	O
good	O
`	O

see	O
also	O
:	O
stackoverflow.com/a/19866269/1240268	O

`	O
NaN	O
`	O
can	O
be	O
used	O
as	O
a	O
numerical	O
value	O
on	O
mathematical	O
operations	O
,	O
while	O
`	O
None	O
`	O
cannot	O
(	O
or	O
at	O
least	O
shouldn't	O
)	O
.	O

`	O
NaN	O
`	O
is	O
a	O
numeric	O
value	O
,	O
as	O
defined	O
in	O
IEEE	O
754	O
floating-point	O
standard	O
.	O

`	O
None	O
`	O
is	O
an	O
internal	O
Python	O
tipe	O
(	O
`	O
NoneType	O
`)	O
and	O
would	O
be	O
more	O
like	O
"	O
inexistent	O
"	O
or	O
"	O
empty	O
"	O
than	O
"	O
numerically	O
invalid	O
"	O
in	O
this	O
context	O
.	O

The	O
main	O
"	O
symptom	O
"	O
of	O
that	O
is	O
that	O
,	O
if	O
you	O
perform	O
,	O
say	O
,	O
an	O
average	O
or	O
a	O
sum	O
on	O
an	O
array	O
containing	O
NaN	O
,	O
even	O
a	O
single	O
one	O
,	O
you	O
get	O
NaN	O
as	O
a	O
result	O
...	O

In	O
the	O
other	O
hand	O
,	O
you	O
cannot	O
perform	O
mathematical	O
operations	O
using	O
`	O
None	O
`	O
as	O
operand	O
.	O

So	O
,	O
depending	O
on	O
the	O
case	O
,	O
you	O
could	O
use	O
`	O
None	O
`	O
as	O
a	O
way	O
to	O
tell	O
your	O
algorithm	O
not	O
to	O
consider	O
invalid	O
or	O
inexistent	O
values	O
on	O
computations	O
.	O

That	O
would	O
mean	O
the	O
algorithm	O
should	O
test	O
each	O
value	O
to	O
see	O
if	O
it	O
is	O
`	O
None	O
`	O
.	O

Numpy	O
has	O
some	O
functions	O
to	O
avoid	O
NaN	O
values	O
to	O
contaminate	O
your	O
results	O
,	O
such	O
as	O
`	O
nansum	O
`	O
and	O
`	O
nan_to_num	O
`	O
for	O
example	O
.	O

I	O
agree	O
with	O
you	O
that	O
None	O
should	O
be	O
used	O
for	O
non-existent	O
entries	O
,	O
so	O
why	O
does	O
`	O
df	O
=p	O
d.readcsv	O
(	O
'	O
file.csv	O
')`	O
give	O
me	O
`	O
NaN	O
`	O
values	O
for	O
the	O
empty	O
cells	O
and	O
not	O
`	O
None	O
`	O
?	O

As	O
far	O
as	O
I'm	O
aware	O
,	O
pd.DataFrames	O
are	O
not	O
exclusive	O
for	O
numbers	O
.	O

Well	O
,	O
it's	O
probably	O
a	O
design	O
choice	O
.	O

I	O
suppose	O
DataFrames	O
and	O
Series	O
have	O
a	O
`	O
dtype	B-API
`	O
,	O
so	O
invalid	O
values	O
of	O
`	O
dtype=float	O
`	O
must	O
be	O
represented	O
by	O
numeric	O
values	O
,	O
which	O
`	O
NaN	O
`	O
is	O
and	O
`	O
None	O
`	O
is	O
not	O
(	O
`	O
None	O
`	O
is	O
of	O
`	O
NoneType	O
`)	O
.	O

Also	O
,	O
a	O
lot	O
of	O
Pandas	O
methods	O
have	O
a	O
`	O
na	O
`	O
argument	O
,	O
which	O
let	O
you	O
decide	O
which	O
value	O
you	O
are	O
going	O
to	O
use	O
to	O
replace	O
not-available	O
values	O

Ok	O
,	O
thanks	O
.	O

So	O
I	O
am	O
not	O
actually	O
reading	O
numbers	O
into	O
my	O
DataFrame	B-API
,	O
but	O
strings	O
of	O
numbers	O
and	O
letters	O
.	O

What	O
sort	O
of	O
check	O
should	O
I	O
be	O
using	O
to	O
detect	O
empty	O
cells	O
?	O

A	O
check	O
like	O
;	O
if	O
dtype	B-API
==	O
float	O
:	O
??	O

Perhaps	O
posting	O
a	O
sample	O
of	O
your	O
CSV	O
data	O
would	O
help	O
.	O

I	O
can	O
imagine	O
that	O
,	O
if	O
there	O
are	O
strings	O
,	O
then	O
dtype	B-API
would	O
be	O
string	O
for	O
the	O
whole	O
column	O
(	O
Series	O
)	O
.	O

But	O
perhaps	O
if	O
not	O
every	O
row	O
has	O
the	O
same	O
number	O
of	O
columns	O
,	O
you	O
end	O
up	O
with	O
unavailable	O
data	O
.	O

I	O
think	O
you'll	O
have	O
to	O
check	O
that	O
.	O

The	O
function	O
`	O
isnan()	O
`	O
checks	O
to	O
see	O
if	O
something	O
is	O
"	O
Not	O
A	O
Number	O
"	O
and	O
will	O
return	O
whether	O
or	O
not	O
a	O
variable	O
is	O
a	O
number	O
,	O
for	O
example	O
`	O
isnan	O
(	O
2	O
)`	O
would	O
return	O
false	O

The	O
conditional	O
`	O
myVar	O
is	O
not	O
None	O
`	O
returns	O
whether	O
or	O
not	O
the	O
variable	O
is	O
defined	O

Your	O
numpy	O
array	O
uses	O
`	O
isnan()	O
`	O
because	O
it	O
is	O
intended	O
to	O
be	O
an	O
array	O
of	O
numbers	O
and	O
it	O
initializes	O
all	O
elements	O
of	O
the	O
array	O
to	O
`	O
NaN	O
`	O
these	O
elements	O
are	O
considered	O
"	O
empty	O
"	O

I	O
think	O
`	O
isnan	O
(	O
2	O
)`	O
would	O
return	O
`	O
False	O
`	O
,	O
since	O
2	O
is	O
not	O
a	O
NaN	O
.	O

Also	O
,	O
`	O
numpy.empty	O
`	O
doesn't	O
initialize	O
array	O
values	O
to	O
`	O
NaN	O
`	O
.	O

It	O
simply	O
doesn't	O
initialize	O
the	O
values	O
at	O
all	O
.	O

@USER	O
idk	O
what	O
i	O
was	O
thinking	O

The	O
proper	O
check	O
for	O
`	O
None	O
`	O
-ness	O
is	O
`	O
myVar	O
is	O
not	O
None	O
`	O
,	O
not	O
`	O
myVar	O
!	O

=	O
None	O
`	O
.	O

Note	O
that	O
`	O
np.isnan()	O
`	O
is	O
not	O
implemented	O
for	O
string	O
variables	O
,	O
so	O
if	O
you	O
pass	O
it	O
a	O
string	O
it	O
will	O
crash	O
.	O

Better	O
to	O
use	O
`	O
pd.isnull	B-API
`	O
which	O
works	O
with	O
strings	O
.	O

`	O
NaN	O
`	O
stants	O
for	O
NOT	O
a	O
number	O
.	O

`	O
None	O
`	O
might	O
stand	O
for	O
any	O
.	O

